## Key Word

- [Persiapan Project](#persiapan-project)
- <details open>
    <summary><a href="#props">Props</a></summary>
    <ul>
      <li><a href="#props-1">Props</a></li>
      <li><a href="#default-props">Default Props</a></li>
    </ul>
  </details>
- <details open>
    <summary><a href="#state-dan-usestate">State dan useState</a></summary>
    <ul>
      <li><a href="#state">state</a></li>
      <li><details open>
        <summary><a href="#usestate">useState</a></summary>
        <ul>
          <li><a href="#usestate-untuk-object">useState Untuk Object</a></li>
          <li><a href="#usestate-untuk-nesting-object">useState Untuk Nesting Object</a></li>
        </ul>
      </details></li>
    </ul>
  </details>
- <details open>
      <summary><a href="#image">Image</a></summary>
      <ul>
        <li><a href="#dari-local">Dari Local</a></li>
        <li><a href="#dari-url">Dari URL (server lain)</a></li>
        <li><a href="#atribute-loading">Atribute Loading</li>
      </ul>
    </details>
- [Inline Style](#inline-style)
- [Atribute Blank di tag <a>](#atribute-target-blank-di-tag-a)
- <details open>
      <summary><a href="#conditional-rendering">Conditional Rendering</a></summary>
      <ul>
        <li><a href="#penerapan-conditional-rendering-untuk-login">Penerapan Conditional Rendering Untuk Login</a></li>
        <li><a href="#penerapan-conditional-rendering-untuk-utiliti-class-di-element-html"> Penerapan Conditional Rendering Untuk Utility Class Di Element HTML</li>
      </ul>
    </details>
- [List Rendering](#list-rendering)
- [Event Handler](#event-handler)
- <details open>
      <summary><a href="#react-router">React Router</a></summary>
      <ul>
        <li><a href="#install-react-router">Install React Router</a></li>
        <li>
         <a href="#konfigurasi-router">Konfigurasi React Router</a>
        </li>
        <li>
         <a href="#link">Link</a>
        </li>
        <li>
         <a href="#useparams">useParams</a>
        </li>
        <li>
         <a href="#usenavigate">useNavigate</a>
        </li>
      </ul>
    </details>
- [useEffect](#useeffect)
- [Warnig Missing Dependency Saat Menggunakan Useeffect](#warnig-missing-dependency-saat-menggunakan-useeffect)
- [Setting Jason Server Fake Api](#setting-json-server-fake-api)
- <details open>
      <summary><a href="#crud-postgetputdelete-request">CRUD API Request</a></summary>
      <ul>
        <li><a href="#get-request">Get Request</a></li>
        <li>
         <a href="#post-request">Post Request</a>
        </li>
        <li>
         <a href="#delete-request">Delete Request</a>
        </li>
        <li>
         <a href="#put-request">PUT Request</a>
        </li>
      </ul>
    </details>
- <details open>
      <summary><a href="#redux">Redux</a></summary>
      <ul>
        <li><a href="#prepare--get-request">Prepare And Get Request</a></li>
        <li>
         <a href="#post-request-1">Post Request</a>
        </li>
        <li>
         <a href="#delete-request-1">Delete Request</a>
        </li>
        <li>
         <a href="#update-data">Update Data</a>
        </li>
      </ul>
    </details>
- <details open>
    <summary><a href="#redux-toolkit">Redux Toolkit</a></summary>
    <ul>
      <li><a href="#prepare">Prepare</a></li>
      <li><a href="#buat-slice">Buat Slice</a></li>
      <li><a href="#buat-store">Buat Store</a></li>
      <li><a href="#menampilkan-state">Menampilkan State</a></li>
      <li><a href="#update-state">Update State</a></li>
      <li><details open>
        <summary><a href="#fetching-api-menggunakan-redux-toolkit">Fetching API Menggunakan Redux Toolkit</a></summary>
        <ul>
          <li><a href="#get-request-1">Get Request</a></li>
          <li><a href="#post-request-2">Post Request</a></li>
          <li><a href="#delete-request-2">Delete Request</a></li>
          <li><a href="#put-request-1">PUT Request</a></li>
        </ul>
      </details></li>
    </ul>
  </details>
- [Redux Persist](#redux-persist)
- [Tailwind CSS](#tailwind-css)
- <details open>
      <summary><a href="#deploy-project-menggunakan-vercel">Deploy Project Menggunakan Vercel</a></summary>
      <ul>
        <li>
         <a href="#deploy-melalui-website-vercel">Deploy Melalui Website Vercel</a>
        </li>
        <li>
         <a href="#deploy-melalui-cli-vercel---prod">Deploy Melalui CLI Vercel</a>
        </li>
      </ul>
    </details>
- [Material Tailwind](#material-tailwind)
- <details open>
      <summary><a href="#kumpulan-fitur">Kumpulan Fitur</a></summary>
      <ul>
        <li>
         <a href="#fitur-copy-teks-ke-clipboard">Fitur Copy Teks Ke Clipboard</a>
        </li>
        <li>
         <a href="#fitur-ganti-contenticon-button-dalam-beberapa-detik">Fitur auto ganti/update state, content, atau icon dalam beberapa detik</a>
        </li>
        <li>
         <a href="#fitur-active-link">Fitur Active Link</a>
        </li>
      </ul>
    </details>
- <details open>
      <summary><a href="#react-beautiful-dnd-fitur-drag-and-drop">React Beautiful DND</a></summary>
      <ul>
        <li>
         <a href="#implementasi-react-beautiful-dnd-di-aplikasi-kanban-board">Implementasi React Beautiful DND di Aplikasi Kanban Board</a>
        </li>
      </ul>
    </details>
- <details open>
      <summary><a href="#react-to-print">React To Print (print pdf)</a></summary>
      <ul>
        <li>
         <a href="#penggunaan-react-to-print">Penggunaan React To Print</a>
        </li>
        <li>
         <a href="#menghandle-style-untuk-hasil-komponen-setelah-di-print">Menghandle style Komponen yang Di-print</a>
        </li>
      </ul>
    </details>
- <details open>
      <summary><a href="#apex-charts">Apex Charts</a></summary>
      <ul>
        <li>
         <a href="#fitur-utama-apexcharts">Fitur Utama Apex</a>
        </li>
        <li>
         <a href="#cara-menggunakan-apexcharts">Cara Penggunaan Apex Charts</a>
        </li>
        <li>
         <a href="#implementasi-apex-charts">Implementasi Apex Charts</a>
        </li>
      </ul>
    </details>
- [Semantic Commit Messages](#smantic-commit-messages)
- [Referensi](#referensi)

## Component

Di dalam React terdapat dua jenis component yaitu [server component](https://nextjs.org/docs/app/building-your-application/rendering/server-components) dan [client component](https://nextjs.org/docs/app/building-your-application/rendering/client-components). Dalam Next js semua component otomatis menjadi Server Component Secara default. Server Components adalah komponen React yang dijalankan di server. Komponen ini dirender di server dan hasilnya dikirimkan ke klien sebagai HTML statis. Server Components cocok digunakan untuk rendering awal halaman dengan data yang diambil dari server, tanpa memerlukan interaktivitas di sisi klien. Client Components adalah komponen React yang dijalankan di klien (browser). Komponen ini memungkinkan penggunaan state dan efek (hooks) untuk menciptakan interaktivitas dinamis di sisi klien. Client Components cocok digunakan untuk elemen yang memerlukan interaktivitas langsung dengan pengguna, seperti form input, tombol, dan elemen dinamis lainnya. Untuk membuat client component kita harus menambahkan 'use client' di awal code. Berikut perbedaan antara keduanya:

### Server Components

1. **Default**
2. Memudahkan dalam data fetching, security, caching, performance, SEO dan streaming.
3. **Rendering**<br/>
   Proses render ada di server dan tidak mengirimkan JS ke browser.
4. **Penggunaan Fungsi Client Side**<br/>
   Tidak bisa menggunakan fungsi client-side (useEffect, event, windwos dll).
5. **Penggunaan Fungsi Server Side**<br/>
   Dapat menggunakan fungsi server-side dari Node.js API
6. **Eksekusi di Server**<br/>
   - Komponen ini dijalankan di server dan hasilnya dikirim ke klien sebagai HTML yang sudah dirender.
7. **Keamanan dan Performa**<br/>
   - Karena dijalankan di server, data sensitif dapat dikelola dengan lebih aman dan performa aplikasi bisa lebih optimal karena beban rendering dipindahkan ke server.
8. **Akses ke Data**<br/>

   - Kemampuan untuk mengambil data dalam proses fetching data dari database lebih cepat, karena dirender di sisi server yang mana prosesnya lebih cepat dibandingkan dengan rendering di sisi client.
   - Komponen ini dapat langsung mengakses data server-side seperti database, API internal, dan file sistem tanpa perlu memikirkan masalah keamanan CORS.

9. **Hanya HTML**
   - Hasil yang dikirim ke klien adalah HTML statis, sehingga tidak memiliki interaktivitas atau state di sisi klien.
10. **Penggunaan dalam Next.js**:
    - Cocok untuk bagian aplikasi yang tidak memerlukan interaktivitas langsung atau hanya memerlukan interaktivitas minimal.

### Client Components

1. **'use client' directive**
   Untuk menggunakan component client kita harus menambahkan directive 'use client' di baris awal code.
2. Bermanfaat untuk interactivity (karena dapat menggunakan hooks) dan Browser API seperti local storage atau geolocation.
3. **Rendering**
   Proses rendering terjadi di server dan browser
4. **Fungsi Client Side**
   Dapat menjalankan fungsi client-side.
5. **Eksekusi di Klien**:
   - Komponen ini dijalankan di browser klien dan menyediakan interaktivitas dinamis dengan pengguna.
6. **Interaktivitas**:
   - Memungkinkan penggunaan state React dan efek (hooks) yang berjalan di sisi klien untuk merespons tindakan pengguna.
7. **Akses Terbatas**:
   - Tidak bisa langsung mengakses resource server-side seperti database atau API internal tanpa membuat permintaan HTTP (fetch/AJAX) ke server.
8. **Penggunaan dalam Next.js**:
   - Cocok untuk bagian aplikasi yang memerlukan interaktivitas langsung seperti form input, tombol, dan elemen dinamis lainnya.

### Penggunaan dalam Next.js

Dalam proyek Next.js, Anda dapat menggabungkan kedua jenis komponen ini untuk memanfaatkan keunggulan masing-masing. Misalnya, Anda dapat menggunakan Server Components untuk rendering awal halaman dengan data dari server dan kemudian menggunakan Client Components untuk menambahkan interaktivitas pada halaman tersebut.

### Contoh Penggunaan

- **Server Component**:

  ```jsx
  // pages/index.js
  import fetchData from '../lib/fetchData';

  export default function Home({ data }) {
    return (
      <div>
        <h1>Data dari Server</h1>
        <pre>{JSON.stringify(data, null, 2)}</pre>
      </div>
    );
  }

  export async function getServerSideProps() {
    const data = await fetchData();
    return { props: { data } };
  }
  ```

- **Client Component**:

  ```
  // components/InteractiveComponent.js
  'use client'
  import { useState } from 'react';

  export default function InteractiveComponent() {
  const [count, setCount] = useState(0);

  return (
      <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
      </div>
    );
  }
  ```

## Routing

Next js Menggunakan router berbasis sistem folder di mana folder digunakan untuk menentukan route. Setiap folder mewakili segmen route yang dipetakan ke segmen URL. page.js, page.jsx, atau page.tsx akan menjadi file special yang ditampilkan

Next.js 14 memperkenalkan fitur **App Router** yang memberikan fleksibilitas dan kontrol yang lebih besar atas routing dalam aplikasi.

App Router memungkinkan developer untuk mengatur navigasi dan layout aplikasi dengan cara yang lebih dinamis dan canggih dibandingkan dengan Page Router. App Router di Next.js 14 menggunakan komponen `next/router` dan hook `useRouter` untuk mengelola rute secara programatik. Ini memberikan kemampuan untuk melakukan navigasi yang lebih kompleks dan dinamis, serta mendukung fitur-fitur canggih seperti dynamic imports dan custom middleware.

#### Nested Route

Next.js 14 memungkinkan Developer untuk membuat nested route dengan mudah menggunakan fitur **App Router**. Nested route memungkinkan pengelompokan dan pengaturan yang lebih terstruktur dari rute dalam aplikasi Next.js. Berikut adalah penjelasan tentang bagaimana membuat nested route menggunakan App Router.

Nested route memungkinkan penataan hierarki yang lebih baik dalam aplikasi web. Dengan nested route, Anda dapat menyusun halaman-halaman dalam struktur yang terkelompok, sehingga membuat navigasi dan pengaturan rute menjadi lebih terorganisir.

Untuk membuat nested route di Next.js 14, Anda dapat menggunakan pendekatan yang mirip dengan pembuatan rute biasa. Namun, Anda akan membuat file dan direktori yang terkelompok di dalam direktori halaman Anda.

```tsx
src/app/
|-- about/
|   |-- page.tsx
|-- blog/
|   |-- first/
|   |   |-- page.tsx
|   |-- second/
|   |   |-- page.tsx
|-- layout.tsx
|-- page.tsx
```

Dalam struktur file yang diberikan, terdapat beberapa halaman yang terorganisir dalam folder `src/app/`. Setiap halaman memiliki path yang berbeda sesuai dengan struktur folder. Berikut cara akses masing - masing halaman menggunakan route berdasarkan struktur file diatas:

- Halaman utama terletak di file `page.tsx`. Untuk mengakses halaman ini, Anda dapat mengunjungi path :`/` atau `https://maindomain.com`
- Halaman About terletak dalam folder `about/` dan didefinisikan di file `page.tsx` di dalamnya. Untuk mengakses halaman About, Anda perlu menambahkan `/about` ke path utama: `https://maindomain.com/about`
- Halaman Blog memiliki dua sub halaman yang terletak dalam folder `blog/first/` dan `blog/second/`. Kedua subhalaman ini didefinisikan di file `page.tsx` masing-masing. Untuk mengakses halaman-halaman ini, Anda dapat menggunakan path berikut:
  - Blog Pertama: `https://maindomain.com/blog/first`
  - Blog Kedua: `https://maindomain.com/blog/second`

#### Dynamic Route

Anda juga dapat menggunakan dynamic route untuk menangani rute yang berubah dinamis. Contoh implementasinya route dinamis digunakan untuk menampilkan halaman detail product berdasarkan id product. Hal ini bisa dilakukan dengan menjadikan id product sebagai path dinamic route.

Dynamic routes dibuat dengan membungkus nama folder di dalam tanda kurung siku: `[namafolder]`. Dynamic segments dapat diakses melalui props di page.tsx, layout.tsx, route.tsx dan generateMetaData functions. Berikut contoh struktur filenya:

```tsx
src/app/
|-- layout.tsx
|-- page.tsx
|-- product
|   |-- [productId]/
|   |   |-- page.tsx
|   |-- page.tsx
```

**Halaman Product**

```tsx
import Link from 'next/link';
import React from 'react';

const Product = () => {
  return (
    <div className="space-x-2 m-10 text-white font-bold">
      <Link href={'/product/1'} className="bg-slate-700 px-4 py-2 rounded-md">
        Product 1
      </Link>
      <Link href={'/product/2'} className="bg-slate-700 px-4 py-2 rounded-md">
        Product 2
      </Link>
    </div>
  );
};

export default Product;
```

**Halaman Detail Product**

```tsx
// /src/app/product/[productId]/page.tsx;

import React from 'react';

const DetailProduct = ({ params }: { params: { productId: string } }) => {
  return <div>Detail Product with Id {params.productId}</div>;
};

export default DetailProduct;
```

Dalam contoh ini, kita menangani rute dinamis untuk menampilkan halaman detail product dengan ID yang sesuai. Sehingga kita dapat mengakses halaman detail product degan path yang dinamis (bebas): `https://maindomain.com/product/1` || `https://maindomain.com/product/{value bebas}`

#### Dinamic Nested Route

Nested dynamic route adalah pola routing di mana satu atau lebih bagian dari URL adalah dinamis dan dapat berubah sesuai dengan konteks atau parameter tertentu. Dalam konteks Next.js, nested dynamic route mengacu pada penggunaan path dinamis di dalam path lain yang juga dinamis. Dalam contoh ini nested route di terapkan untuk mengakses halaman `reviews`, di mana untuk mengkakses halaman tersebut kita membutuhkan 2 parameter yang dinamis yaitu product id dan review id.

```tsx
src/app/
|-- layout.tsx
|-- page.tsx
|-- product
|   |-- [productId]/
|   |   |-- reviews/
|   |   |   |-- [reviewId]
|   |   |   |   |-- page.tsx
|   |   |-- page.tsx
|   |-- page.tsx
```

**Halaman Review Id**

```tsx
import React from 'react';

const ReviewDetail = ({
  params,
}: {
  params: { productId: string; reviewId: string };
}) => {
  return (
    <div>
      <h1>
        Reviews detail page with product id {params.productId} and review id{' '}
        {params.reviewId}
      </h1>
    </div>
  );
};

export default ReviewDetail;
```

Navigasi ke nested route dapat dilakukan dengan membuat tautan dengan parameter yang sesuai, misalnya kita ingin mengakses halaman review product tersebut dengan id product 20 dan id review 100 paka pathnya akan seperti ini `https://maindomain.com/product/20/reviews/100`

#### Catch All Segments

Dalam Next.js, Route Catch-All Segments digunakan untuk menangani rute dinamis dengan cara yang lebih fleksibel. Fitur ini sangat berguna ketika kita ingin menangani berbagai tingkat kedalaman URL yang tidak ditentukan sebelumnya. Berikut beberapa keunggulan lainnya:

- **Fleksibilitas**: Memungkinkan kita untuk menangani URL dengan struktur yang kompleks tanpa perlu membuat file untuk setiap kemungkinan rute.
- **Kemudahan Pengelolaan**: Mengurangi jumlah file dan folder yang perlu kita buat dan kelola.
- **Navigasi Dinamis**: Memungkinkan navigasi dinamis berdasarkan parameter URL yang dapat bervariasi dalam jumlah dan konten.

Dengan menggunakan catch-all route, kita dapat menangani berbagai skenario routing dengan cara yang lebih efisien dan terstruktur. Hal ini sangat berguna untuk aplikasi yang memiliki banyak halaman dinamis seperti dokumentasi, blog dengan kategori yang dalam, atau e-commerce dengan berbagai kategori produk.

Berikut adalah contoh struktur file yang digunakan dalam route cathc all segments:

```tsx
src/app/
|-- transactions/
|   |   |-- [...slug]/
|   |   |   |    |-- page.tsx
|-- layout.tsx
|-- page.tsx
```

Berikut code di file `src/app/transactions/[...slug]/page.tsx`:

```tsx
import React from 'react';

const Docs = ({ params }: { params: { slug: string[] } }) => {
  console.log(params.slug);

  // Jika slug adalah array tunggal atau tidak ada
  if (!params?.slug || params?.slug?.length === 0) {
    return (
      <div>
        <h1 className="text-3xl font-bold text-center">Docs Page</h1>
        <p>Welcome to the Docs page. Please select a document.</p>
      </div>
    );
  }

  // Jika slug memiliki satu atau lebih segmen
  return (
    <div>
      <h1 className="text-3xl font-bold text-center">Docs Page</h1>
      <p>Transactions Page with slug: {params?.slug?.join('/')}</p>
    </div>
  );
};

export default Docs;
```

Kemudian misalnya kita ingin mengakses page dogs dengan path yang dinamis: `https://maindomain.com/transactions/tas/indonesia/Jakarta`, maka kita bisa menangkap semua parameter yang ada disana `slug = ['tas', 'indonesia', 'jakarta']`

#### Route Groups

Route Groups adalah cara untuk mengelompokkan beberapa rute ke dalam satu grup logis tapi tidak berpengaruh pada path routenya. Misalnya, jika kita memiliki beberapa rute `login` dan `register` di mana keduanya berhubungan dengan `auth`, kita bisa mengelompokkannya ke dalam satu grup yang disebut `auth` [ref](https://www.youtube.com/watch?v=UyIe8Tqjuq8&t=48m15s). Berikut adalah contoh struktur folder yang menggunakan Route Groups:

```
app/
├── (auth)/
│   ├── login/
│   │   └── page.tsx
│   ├── register/
│   │   └── page.tsx
├── layout.tsx
├── page.tsx
```

Sehingga untuk mengakses halaman `login` kita menggunakan route `basedomain.com/login` bukan `basedomain.com/auth/login`

#### Private Folders

Merupakan optional folder yang memisahkan diri dari routing system. Cara membuatnya adalah dengan memberikan uderscore `(_)` dia awal nama folder seperti ini `_namafolder`. Akibatnya semua child segment dari private folder tidak bisa diakses routing [ref](<[ref](https://www.youtube.com/watch?v=UyIe8Tqjuq8&t=45m3s)>). Misalnya kita membuat private folder seperti ini:

```
app/
├── _helpers/
│   ├── page.tsx
├── public/
│   ├── page.tsx
├── layout.tsx
├── page.tsx
├── ...
```

Maka semua child segment dari private folder `helpers` tidak bisa diakses routing.

## Navigation

Ada 4 cara untuk navigate keroute lain di next.js [ref](https://www.youtube.com/watch?v=UyIe8Tqjuq8&t=1h14m51s):

1. Menggunakan `<Link>` Component
2. Menggunakan useRouter hooks (client components)
3. Menggunakan redirect function (server components)
4. Menggunakan history API

### Mengenal Property Prefetch Scroll dan Replace di Tag Link di Next.js

#### Property Prefetch

Property prefetch di link component sudah dibahas [di sini](#prefetch)

#### Property Scroll

Property scroll digunakan untuk mengatur apakah link tersebut akan menggeser halaman ke atas saat di-klik. Jika nilai scroll adalah true, maka link tersebut akan menggeser halaman ke atas saat di-klik. Jika nilai scroll adalah false, maka link tersebut tidak akan menggeser halaman ke atas saat di-klik.

```tsx
// src/components/Footer.tsx

import Link from 'next/link';

const Footer = () => {
  return (
    <footer className="border-t py-3 text-center text-xs">
      <ul className="flex space-x-4">
        <li>
          <Link href="/" className="text-gray-800 hover:underline">
            Home
          </Link>
        </li>
        <li>
          <Link
            href="/blog"
            prefetch={false}
            className="text-gray-800 hover:underline"
          >
            Blog
          </Link>
        </li>
        <li>
          <Link
            //--------------------------------------------------------------------------------------------
            scroll={false}
            //--------------------------------------------------------------------------------------------
            prefetch={false}
            href="/about"
            className="text-gray-800 hover:underline"
          >
            About
          </Link>
        </li>
        <li>
          <Link
            replace={true}
            href="/product"
            className="text-gray-800 hover:underline"
          >
            Product
          </Link>
        </li>
      </ul>
      I&lsquo;m here to stay (Footer)
    </footer>
  );
};

export default Footer;
```

#### Property Replace

Property replace digunakan untuk mengatur apakah link tersebut akan menggantikan URL saat di-klik. Jika nilai replace adalah true, maka link tersebut akan menggantikan URL saat di-klik. Jika nilai replace adalah false, maka link tersebut tidak akan menggantikan URL saat di-klik.

```tsx
// src/components/Footer.tsx

import Link from 'next/link';

const Footer = () => {
  return (
    <footer className="border-t py-3 text-center text-xs">
      <ul className="flex space-x-4">
        <li>
          <Link href="/" className="text-gray-800 hover:underline">
            Home
          </Link>
        </li>
        <li>
          <Link
            href="/blog"
            prefetch={false}
            className="text-gray-800 hover:underline"
          >
            Blog
          </Link>
        </li>
        <li>
          <Link
            scroll={false}
            prefetch={false}
            href="/about"
            className="text-gray-800 hover:underline"
          >
            About
          </Link>
        </li>
        <li>
          <Link
            //---------------------------------------------------------------------------------
            replace={true}
            //---------------------------------------------------------------------------------
            href="/product"
            className="text-gray-800 hover:underline"
          >
            Product
          </Link>
        </li>
      </ul>
      I&lsquo;m here to stay (Footer)
    </footer>
  );
};

export default Footer;
```

### Membuat Style Active untuk Component Link menggunakan usePathname di Next.js

Dalam pengembangan aplikasi web menggunakan Next.js, kita seringkali menggunakan component Link untuk membuat link antar halaman. Namun, terkadang kita ingin membuat link yang aktif (active) ketika user sedang berada di halaman tersebut. Dalam hal ini, kita dapat menggunakan hook usePathname dari Next.js untuk membuat style active untuk component Link.

Hook usePathname dari Next.js digunakan untuk mendapatkan path current URL. Kita dapat menggunakan hook ini untuk membuat style active untuk component Link.

```tsx
// src/components/Navbar.tsx

'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';

const Navbar = () => {
  const pathname = usePathname();

  return (
    <nav>
      <ul className="flex space-x-4">
        <li>
          <Link
            href="/"
            className={pathname === '/' ? 'text-blue-700' : 'text-gray-800'}
          >
            Home
          </Link>
        </li>
        <li>
          <Link
            href="/blog"
            prefetch={false}
            className={pathname === '/blog' ? 'text-blue-700' : 'text-gray-800'}
          >
            Blog
          </Link>
        </li>
        <li>
          <Link
            href="/about"
            prefetch={false}
            className={
              pathname === '/about' ? 'text-blue-700' : 'text-gray-800'
            }
          >
            About
          </Link>
        </li>
        <li>
          <Link
            href="/product"
            className={
              pathname === '/product' ? 'text-blue-700' : 'text-gray-800'
            }
          >
            Product
          </Link>
        </li>
      </ul>
    </nav>
  );
};

export default Navbar;
```

### Navigasi Menggunakan useRouter

Hook useRouter dari Next.js digunakan untuk mendapatkan instance router yang dapat digunakan untuk melakukan navigation. Kita dapat menggunakan hook ini untuk mendapatkan instance router dan kemudian menggunakan fungsi-fungsi yang tersedia di dalamnya untuk melakukan navigation.

```tsx
'use client';

import { useRouter } from 'next/navigation';

export default function SportPage() {
  const router = useRouter();

  return (
    <div clasName="h-[900]">
      <button onClick={() => router.push('/products')}>
        Go back to Products
      </button>
    </div>
  );
}
```

### Navigasi Menggunakan Redirect

Fungsi redirect dari Next.js digunakan untuk melakukan redirect ke halaman lain. Kita dapat menggunakan fungsi ini untuk melakukan redirect ke halaman lain secara otomatis atau dengan menggunakan parameter.

```tsx
import { redirect } from 'next/navigation';

export default function SportPage() {
  const isAdmin = true;

  if (!isAdmin) {
    redirect('/products');
  }

  return <h2 clasName="h-[900]">Sports Page </h2>;
}
```

## Prefetch

Prefetch adalah fitur penting di Next.js yang memungkinkan peningkatan performa aplikasi dengan cara memuat data atau halaman sebelum user benar-benar membutuhkannya. Hal ini memungkinkan pengalaman user yang lebih mulus dan cepat [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10277).

### Apa Itu Prefetch?

Prefetch adalah teknik yang digunakan untuk mengambil sumber daya (resource) yang kemungkinan besar akan dibutuhkan oleh user di masa depan. Dalam konteks Next.js, ini biasanya digunakan untuk memuat halaman secara proaktif sebelum user menavigasi ke halaman tersebut.
Misalnya, saat kita berada di Home Page, ada link ke halaman "About". Dengan prefetch, Next.js akan mulai memuat konten halaman "About" di belakang layar segera setelah link tersebut muncul di layar atau saat user mengarahkan kursor ke link tersebut.

Tujuan dari prefetch ini adalah untuk mengurangi waktu tunggu ketika user akhirnya mengklik link tersebut. Karena sebagian atau seluruh konten halaman "About" sudah dimuat sebelumnya, halaman tersebut bisa ditampilkan dengan lebih cepat dibandingkan jika harus memuat konten dari awal saat link diklik.

### Bagaimana Prefetch Bekerja di Next.js?

Di Next.js, prefetch biasanya digunakan bersama dengan komponen `Link`. Ketika link muncul di viewport, Next.js akan otomatis memulai proses prefetch untuk halaman tujuan link tersebut.

### Implementasi Prefetch dengan `Link`

Berikut adalah contoh sederhana menggunakan komponen `Link` dengan prefetch di Next.js:

```tsx
<header>
  <nav>
    <ul className="flex space-x-4">
      <li>
        <Link href="/">Home</Link>
      </li>
      <li>
        <Link href="/blog" prefetch={false}>
          Blog
        </Link>
      </li>
      <li>
        <Link href="/about" prefetch={false}>
          About
        </Link>
      </li>
      <li>
        <Link href="/product">Product</Link>
      </li>
    </ul>
  </nav>
</header>
```

Pada contoh di atas, ketika halaman HomePage dirender, Next.js akan secara otomatis melakukan prefetch halaman `/about` saat link berada di viewport.

### Mengontrol Prefetching

#### Menonaktifkan Prefetch

Secara default, Next.js akan melakukan prefetch untuk semua tautan yang menggunakan komponen `Link`. Namun, ada kalanya Anda mungkin ingin menonaktifkan prefetch untuk tautan tertentu. Anda dapat melakukannya dengan menambahkan atribut `prefetch={false}` pada komponen `Link`.

```jsx
import Link from 'next/link';

export default function HomePage() {
  return (
    <div>
      <h1>Home Page</h1>
      <Link href="/about" prefetch={false}>
        <a>About</a>
      </Link>
    </div>
  );
}
```

#### Prefetch Manual

Selain menggunakan prefetch otomatis, Anda juga bisa melakukan prefetch manual pada halaman yang diinginkan menggunakan fungsi `router.prefetch()`.

```jsx
import { useEffect } from 'react';
import { useRouter } from 'next/router';

export default function HomePage() {
  const router = useRouter();

  useEffect(() => {
    router.prefetch('/about');
  }, [router]);

  return (
    <div>
      <h1>Home Page</h1>
      <a href="/about">About</a>
    </div>
  );
}
```

Pada contoh di atas, halaman /about akan diprefetch segera setelah komponen HomePage dirender.

### Kapan Menggunakan Prefetch?

- Navigasi Antara Halaman yang Sering Dikunjungi <br/>
  Prefetch sangat berguna untuk halaman yang sering dikunjungi pengguna. Ini memastikan bahwa halaman-halaman ini akan dimuat dengan cepat ketika pengguna menavigasi ke sana.
- Konten Dinamis <br/>
  Jika aplikasi kita memiliki konten yang sering berubah atau dinamis, prefetch bisa membantu dengan mengambil data yang dibutuhkan sebelumnya.
- Pengalaman Pengguna yang Lebih Baik <br/>
  Dengan prefetch, kita dapat meningkatkan pengalaman pengguna dengan mengurangi waktu tunggu saat berpindah halaman.

### Keuntungan Menggunakan Prefetch

- **Pengalaman Pengguna yang Lebih Baik:** Mengurangi waktu muat halaman berikutnya.
- **Efisiensi Jaringan:** Menggunakan idle time untuk memuat resource yang akan dibutuhkan.
- **Navigasi Lebih Cepat:** Halaman yang diprefetch akan terasa lebih cepat saat diakses.

### Kesimpulan

Prefetch di Next.js adalah fitur yang kuat untuk meningkatkan performa aplikasi Anda dengan memuat halaman atau data yang kemungkinan besar akan dibutuhkan oleh pengguna di masa depan. Dengan menggunakannya secara efektif, Anda dapat memberikan pengalaman pengguna yang lebih mulus dan responsif.

## Font

Kita masih gagal menggunakan Saat menambahkan font menggunakan tailwind css. Tapi kita telah berhasil menambahkan font secara manual langsung dari google font [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10288), berikut caranya:

- Import google font yang ingin digunakan dan inisialisasi font tersebut di file baru (`src/app/fonts.ts).

  ```ts
  //src/app/fonts.ts
  import { Inter, Oswald, Playfair_Display } from 'next/font/google';

  export const oswald = Oswald({
    subsets: ['latin'],
    weight: ['400', '700'],
  });

  export const inter = Inter({
    subsets: ['latin'],
    display: 'swap',
    variable: '--font-inter',
    // preload: false,
  });

  export const playfair = Playfair_Display({
    subsets: ['latin'],
    display: 'swap',
    variable: '--font-playfair-display',
    // preload: false,
  });
  ```

- Import dan gunakan font yang sudah diinisialisasi ke tag html yang diinginkan.

  ```tsx
  //src/app/blog/page.tsx
  import Heading from '@/components/Heading';
  import PostCard from '@/components/PostCard';
  import React from 'react';
  import { inter } from '../fonts';

  const BlogPage = () => {
    return (
      <>
        <Heading>Blog Page</Heading>
        <h2 className={`text-2xl mb-3 ${inter.className}`}>List of Post</h2>
        <PostCard
          author="Admin"
          date="20 June 2024"
          description="Lorem ipsum dolor sit amet, consectetur adipisicing elit. Velit facere rem aperiam eaque similique distinctio nisi eius, hic ducimus laborum?"
          href="/blog/learn-nextjs"
          image="/images/natureBigWall.jpg"
          title="Belajar Next.js"
        />
      </>
    );
  };

  export default BlogPage;
  ```

## Mengelola dan Menampilkan Konten Markdown

### Membaca File Markdown di Nextjs

Untuk membaca file Markdown kita bisa mengguanakn `readFile` dari node js. Untu menggunakan `readFile` kita harus mengguanakan asychronous dan di server component [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10290).

Untuk memastikan path letak file markdown kita benar, sebaiknya gunakan `path.join` dan `process.cwd()` untuk membentuk path absolut dari root proyek kita.

Berikut langkah - langkah untuk membaca file markdown di next js:

- Buat file markdown yang ingin dibaca:

  ```md
  <!-- src/contents/blog/belajar-nextjs.md -->

  # Heading

  ## Sub heading

  Rich text with **bold** dan _italic_.

  paragraph baru

  List:

  - satu
  - dua
  ```

- Di file tempat kita ingin membaca file markdown di atas, lakukan:

  - Import modul `path` untuk membentuk path absolut.
  - Gunakan `path.join` dan `process.cwd()`. Gabungkan path relatif dengan direktori kerja proses saat ini (`process.cwd()`) untuk membentuk path absolut.
  - Import dan gunakan `readFile()` untuk membaca file markdown di atas.

    ```tsx
    //src/app/blog/learn-nextjs/page.tsx
    import Heading from '@/components/Heading';
    //-----------------------------------------------------
    import { readFile } from 'fs/promises';
    import path from 'path';
    //-----------------------------------------------------
    import React from 'react';

    const LearnNext = async () => {
      //-----------------------------------------------------
      const filePath = path.join(
        process.cwd(),
        'src/contents/blog/belajar-nextjs.md'
      );
      const text = await readFile(filePath, 'utf8');
      //-----------------------------------------------------

      return (
        <>
          <Heading>Belajar Next JS</Heading>
          <img
            src="/images/natureBigWall.jpg"
            alt="natural"
            width={640}
            height={360}
            className="mb-2 rounded"
          />
          //--------------------------------------------------
          <p>{text}</p>
          //--------------------------------------------------
        </>
      );
    };

    export default LearnNext;
    ```

- Kita telah berhasil menampilkan file markdown meskipun bukan dalam tampilan yang bagus, masih dalam code markdown

### Menampilkan Data markdown pada component / Mengkonversi element markdown (hasil dari langkah [Membaca File Markdown](#membaca-file-markdown-di-nextjs)) menjadi tag html

Kita dapat mengkonversi elemen markdown menjadi tag html menggunakan package [marked](https://www.npmjs.com/package/marked). Berikut langkah - langkahnya [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10291):

- Install [marked](https://www.npmjs.com/package/marked).
- Konversi element markdown menjadi tag html menggunakan marked.
- Suntikkan code html yang dihasilkan ke dalam komponen menggunakan property `dangerouslySetInnerHTML`.

```tsx
//src/app/blog/learn-nextjs/page.tsx
import Heading from '@/components/Heading';
import { readFile } from 'fs/promises';
import path from 'path';
//---------------------------------------------------------
import { marked } from 'marked';
//---------------------------------------------------------
import React from 'react';

const LearnNext = async () => {
  const filePath = path.join(
    process.cwd(),
    'src/contents/blog/belajar-nextjs.md'
  );
  const text = await readFile(filePath, 'utf8');
  //--------------------------------------------------------
  const html = marked(text);
  //--------------------------------------------------------
  return (
    <>
      <Heading>Belajar Next JS</Heading>
      <img
        src="/images/natureBigWall.jpg"
        alt="natural"
        width={640}
        height={360}
        className="mb-2 rounded"
      />
      //-----------------------------------------------------
      <article dangerouslySetInnerHTML={{ __html: html }} />
      //-----------------------------------------------------
    </>
  );
};

export default LearnNext;
```

`dangerouslySetInnerHTML` adalah properti khusus di React yang memungkinkan kita untuk menampilkan konten HTML dalam komponen React secara langsung dari string HTML. Properti ini berguna saat kita perlu menampilkan HTML yang dihasilkan secara dinamis atau berasal dari sumber eksternal, seperti konten markdown yang telah diubah menjadi HTML.

### Menampilkan Style Markdown Yang Sesuai Dengan Tailwindcss

Untuk menambahkan style pada hasil konversi elemen Markdown ke tag html di tailwindcss kita harus menggunakan plugin [typography](https://github.com/tailwindlabs/tailwindcss-typography). Berikut langkah - langkahnya [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10292):

- Intall plugin typography [ref](https://github.com/tailwindlabs/tailwindcss-typography)
- Setelah proses instalasi selesai, kita bisa menambahkan class tailwind di tag html tempat kita menampilkan hasil konversi elemen markdown ke tag html

  ```tsx
  import Heading from '@/components/Heading';
  import { readFile } from 'fs/promises';
  import path from 'path';
  import { marked } from 'marked';
  import React from 'react';

  const LearnNext = async () => {
    const filePath = path.join(
      process.cwd(),
      'src/contents/blog/belajar-nextjs.md'
    );
    const text = await readFile(filePath, 'utf8');
    const html = marked(text);
    return (
      <>
        <Heading>Belajar Next JS</Heading>
        <img
          src="/images/natureBigWall.jpg"
          alt="natural"
          width={640}
          height={360}
          className="mb-2 rounded"
        />
        //--------------------------------------------------
        <article
          dangerouslySetInnerHTML={{ __html: html }}
          className="prose max-w-screen-sm text-red-900"
        />
        //--------------------------------------------------
      </>
    );
  };

  export default LearnNext;
  ```

### Mengambil dan Menampilkan Data Meta / Variable (Data Dinamis) di File Markdown

Untuk bisa memisahkan data (data variabel/meta) dan component (elemen markdown yang akan dikonversi ke tag html) kita bisa menggunakan package [gray-metter](https://www.npmjs.com/package/gray-matter). Berikut langkah - langkahnya [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10293):

- Buat data meta di file markdown

  ```md
  ## <!-- contents/blog/belajar-nextjs.md -->

  title: 'Belajar Next.js'
  image: '/images/natureBigWall.jpg'
  date: '26/11/2023'
  author: 'admin'

  ---

  # Heading

  ## Sub heading

  Rich text with **bold** dan _italic_.

  paragraph baru

  List:

  - satu
  - dua
  ```

- Install package gray-matter
- Destruct data dan component yang ada di file markdown menggunakan `gray-matter` dan gunakan data dan component tersebut untuk ditampilkan di tag html.

```tsx
//src/app/blog/learn-nextjs/page.tsx
import Heading from '@/components/Heading';
import { readFile } from 'fs/promises';
import path from 'path';
import { marked } from 'marked';
//-------------------------------------------------
import metter from 'gray-matter';
//-------------------------------------------------
import React from 'react';

const LearnNext = async () => {
  const filePath = path.join(
    process.cwd(),
    'src/contents/blog/belajar-nextjs.md'
  );
  const text = await readFile(filePath, 'utf8');
  //-------------------------------------------------
  const {
    content,
    data: { title, image, date, author },
  } = metter(text);
  const html = marked(content);
  //-------------------------------------------------

  return (
    <>
      //-------------------------------------------------
      <Heading>{title}</Heading>
      <p className="italic text-sm pb-2">
        {date} - {author}
      </p>
      <img
        src={image}
        alt="natural"
        width={640}
        height={360}
        className="mb-2 rounded"
      />
      //-------------------------------------------------
      <article
        dangerouslySetInnerHTML={{ __html: html }}
        className="prose max-w-screen-sm text-red-900"
      />
    </>
  );
};

export default LearnNext;
```

### Refaktor: Memisahkan Layer Data Dengan Layer Ui

Dari semua langkah untuk mengelola content dari file markdown diatas, masih ada satu langkah lagi yaitu refaktor agar code kita lebih clean. Kita bisa merefaktor dengan memisahkan bagian yang fungsinya untuk mengambil data dari file markdown dan bagian yang fungsinya untuk menampilkan data yang diperoleh dari file markdown tersebut [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10294). Berikut langkah - langkahnya:

- Kelompokkan code yang digunakan untuk mengambil data dari file markdown ke dalam satu function dan buat function tersebut di file yang berbeda, dalam contoh ini diletakkan di `src/libs/post.ts`.

  ```ts
  //src/libs/post
  import { readFile } from 'fs/promises';
  import path from 'path';
  import { marked } from 'marked';
  import metter from 'gray-matter';

  export const getPostBySlug = async (slug: string) => {
    const filePath = path.join(process.cwd(), `src/contents/blog/${slug}.md`);
    const text = await readFile(filePath, 'utf8');

    const {
      content,
      data: { title, image, date, author },
    } = metter(text);
    const body = marked(content);

    return { title, image, date, author, body };
  };
  ```

- Import dan gunakan nilai yang direturn function tadi, sehingga code kita yang awalnya [ini](#mengambil-dan-menampilkan-data-meta--variable-data-dinamis-di-file-markdown) jadi seperti ini:

  ```tsx
  //src/app/blog/learn-nextjs/page.tsx
  import Heading from '@/components/Heading';
  import { getPostBySlug } from '@/libs/post';
  import React from 'react';

  const LearnNext = async () => {
    const post = await getPostBySlug('belajar-nextjs');
    return (
      <>
        <Heading>{post.title}</Heading>
        <p className="italic text-sm pb-2">
          {post.date} - {post.author}
        </p>
        <img
          src={post.image}
          alt="natural"
          width={640}
          height={360}
          className="mb-2 rounded"
        />
        <article
          dangerouslySetInnerHTML={{ __html: post.body }}
          className="prose max-w-screen-sm text-red-900"
        />
      </>
    );
  };

  export default LearnNext;
  ```

## Mengambil Data List Contents Berdasarkan Jumlah File Yang Ada di folder contents/blog dengan ekstensi md (markdown)

Kita bisa mengambil daftar semua contents yang ada yang ada di folder `contents/blog` yang dibuat menggunakan file markdown. Dari data itu kita juga bisa membuat path/slug yang nantinya bisa dijadikan params untuk membuat route dinamis di mana page yang tampil adalah contents di folder `content/blog`. Berikut cara untuk mendapatkan data [list contens](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10296) dan [menampilkan data tersebut dalam halaman](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10297).

- Buat function yang berfungsi untuk mendapatkan semua konten dari file berextensi .md dari direktori src/contents/blog/ di file yang sama dengan function yang digunakan untuk mendapatkan data content dari file markdown di contoh ini di file `src/libs/post.ts

  ```ts
  // src/libs/post.ts

  // Fungsi untuk mendapatkan semua konten dari file berextensi .md dari direktori src/contents/blog/
  export const getAllContents = async (): Promise<Post[]> => {
    // Membaca file dari direktori src/contents/blog
    const files = await readdir(
      path.join(process.cwd(), './src/contents/blog')
    );

    // Memfilter file yang berakhiran .md dan hapus ekstensi .md untuk mendapatkan slug
    const slugs = files
      .filter((file) => file.endsWith('.md'))
      .map((file) => file.slice(0, -'.md'.length));

    // Menginisialisasi array untuk menampung post
    const posts: Post[] = [];

    // Mengambil data post berdasarkan slug dan menambahkannya ke array posts
    for (const slug of slugs) {
      const post = await getPostBySlug(slug);
      posts.push(post);
    }

    // Mengembalikan array posts
    return posts;
  };
  ```

- Panggil function `getAllContents` tersebut untuk mendapatkan semua konten dari file berextensi .md dari direktori src/contents/blog/ dan tampilakan data content yang diperoleh di component

  ```tsx
  import Heading from '@/components/Heading';
  import PostCard from '@/components/PostCard';
  import React from 'react';
  import { inter } from '../fonts';
  import { getAllContents } from '@/libs/post';

  const BlogPage = async () => {
    //------------------------------------------------------------------------
    const contens = await getAllContents();
    //------------------------------------------------------------------------

    return (
      <>
        <Heading>Blog Page</Heading>
        <h2 className={`text-2xl mb-3 ${inter.className}`}>List of Post</h2>
        //---------------------------------------------------------------------
        {contens?.map((content) => (
          <PostCard
            author={content.author}
            date={content.date}
            description={content.description}
            href={`/blog/${content.slug}`}
            image={content.image}
            title={content.title}
          />
        ))}
        //---------------------------------------------------------------------
      </>
    );
  };

  export default BlogPage;
  ```

## Template Meta Data Agar Title Menjadi Dinamis Setiap Halaman

Kita bisa membuat title yang berbeda di setiap page [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10300) [ref2](https://www.youtube.com/watch?v=UyIe8Tqjuq8&t=1h0m09s):

- Buat template meta data dengan title yang berisi default dan template di file layout page utama (`src/app/layout.tsx`)

  ```tsx
  //src/app/layout.tsx
  import type { Metadata } from 'next';
  import { oswald } from './fonts';
  import './globals.css';
  import Navbar from '@/components/Navbar';

  // --------------------------------------------------------------
  export const metadata: Metadata = {
    title: {
      default: 'Next 14 Playground',
      template: '%s | Next 14 Playground',
    },
    description: 'Next 14 Playground, playing around with Next 14',
  };
  // --------------------------------------------------------------

  export default function RootLayout({
    children,
  }: Readonly<{
    children: React.ReactNode;
  }>) {
    return (
      // <html lang="en" className={`${inter.variable} ${playfair.variable}`}>
      <html lang="en">
        <head>
          <link rel="icon" href="/icon.ico" sizes="any" />
          <link rel="icon" href="/icon.png" type="image/png" sizes="16x16" />
          <link
            rel="icon"
            href="/apple-icon.png"
            type="image/png"
            sizes="16x16"
          />
          <link
            rel="apple-touch-icon"
            href="/icon.png"
            type="image/png"
            sizes="16x16"
          />
        </head>
        <body
          className={`${oswald.className} p-4 min-h-screen flex flex-col bg-gray-100`}
        >
          <header>
            <Navbar />
          </header>
          <main className="py-3 grow">{children}</main>
          <footer className="border-t py-3 text-center text-xs">
            I&lsquo;m here to stay (Footer)
          </footer>
        </body>
      </html>
    );
  }
  ```

  title default akan digunakan di page utama atau di page lain ketika di page tersebut tidak didefinisikan titlenya.

- Buat metadata untuk Page lain, misalnya untuk blog page

  ```tsx
  // src/app/blog/layout.tsx
  import { Metadata } from 'next';
  import React from 'react';

  export const metadata: Metadata = {
    title: 'Blog',
    description: 'Next 14 Playground on blog page',
  };

  const BlogLayout = ({ children }: { children: React.ReactNode }) => {
    return (
      <div className="flex">
        <div className="">[Sidebar]</div>
        <div className="px-4">{children}</div>
      </div>
    );
  };

  export default BlogLayout;
  ```

Sehigga saat kita mengakes page utama titlenya akan jadi `Next 14 Playground` dan saat kita mengakser page blog titlenya jadi `Blog | Next 14 Playground`.

## Menambahkan Favicon / icon aplikasi [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10302)

## Membuat Fitur Copy Link

Kita bisa membuat fitur copy link menggunakan Api browser `navigator.clipboard.writeText(window.location.href)`:

- `navigator.clipboard.writeText` berfungsi untuk menyalin URL tersebut ke clipboard.
- `window.location.href` berfungsi untuk mendapatkan URL (di search bar user) saat ini.

Untuk bisa menggunakan api browser tersebut kita harus menggunakannya di component client, API browser yang hanya tersedia di lingkungan client (browser), bukan di lingkungan server. [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10304). Berikut contohnya di coding:

```tsx
// src/components/ShareLinkButton.tsx
'use client';
import React, { useState } from 'react';

const ShareLinkButton = () => {
  const [copied, setCopied] = useState(false);

  const HandleCopyLink = () => {
    navigator.clipboard.writeText(window.location.href);
    setCopied(true);
    setTimeout(() => setCopied(false), 1500);
  };

  return (
    <button
      className="border px-2 py-1 rounded text-sm hover:bg-gray-200 hover:text-gray-700"
      onClick={HandleCopyLink}
    >
      {copied ? 'Link Copied' : 'Copy Link'}
    </button>
  );
};

export default ShareLinkButton;
```

## Deployment

Untuk persiapan deployment, di next js ada dua jenis kita bisa menggunakan static page export dan full next js feature [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10306).
| Static Page Export| Full Next js Feature |
|-------------------|----------------------|
| Bisa menggunakan semua jenis web server | Node js Server |
| Atau semua layanan platform static web | Penyedia platform seperti vercel, netifly, AWS, etc |

### Persiapan Deploy Project Static Page

Untuk melakukan deploy project static page di next js, kita harus Membuat fungsi generete agar setiap halaman di project kita menjadi static. Berikut beberapa persiapan yang harus dilakukan [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10306):

- Di fungsi untuk mendapatkan semua list content pisahkan logic slug buat di fungsi yang berbeda. <br/>
  Logic slug tersebut dipisah agar fungsi logic slug tersebut bisa digunakan untuk melakukan generate parameter statis menggunakan fungsi `generateStatisParams`. Sehingga function `getAllContents()` yang awalnya seperti ini:

  ```ts
  // src/libs/post.ts
  export const getAllContents = async (): Promise<Post[]> => {
    // Membaca file dari direktori src/contents/blog
    const files = await readdir(
      path.join(process.cwd(), './src/contents/blog')
    );

    // Memfilter file yang berakhiran .md dan hapus ekstensi .md untuk mendapatkan slug
    const slugs = files
      .filter((file) => file.endsWith('.md'))
      .map((file) => file.slice(0, -'.md'.length));

    // Menginisialisasi array untuk menampung post
    const posts: Post[] = [];

    // Mengambil data post berdasarkan slug dan menambahkannya ke array posts
    for (const slug of slugs) {
      const post = await getPostBySlug(slug);
      posts.push(post);
    }

    // Mengembalikan array posts
    return posts;
  };
  ```

  Akan jadi seperti ini:

  ```ts
  // src/libs/post.ts
  export const getSlugs = async (): Promise<string[]> => {
    const slugs = await getSlugs();

    // Menginisialisasi array untuk menampung post
    const posts: Post[] = [];

    // Mengambil data post berdasarkan slug dan menambahkannya ke array posts
    for (const slug of slugs) {
      const post = await getPostBySlug(slug);
      posts.push(post);
    }

    // Mengembalikan array posts
    return posts;
  };

  export async function getSlugs(): Promise<string[]> {
    // Membaca file dari direktori src/contents/blog
    const files = await readdir(
      path.join(process.cwd(), './src/contents/blog')
    );

    // Memfilter file yang berakhiran .md dan hapus ekstensi .md untuk mendapatkan slug
    const slugs = files
      .filter((file) => file.endsWith('.md'))
      .map((file) => file.slice(0, -'.md'.length));

    return slugs;
  }
  ```

- Membuat Halaman Dinamis menjadi statis dengan function generateStaticParams <br/>
  Fungsi generateStaticParams digunakan untuk menghasilkan parameter statis berdasarkan slug untuk setiap halaman content blog (`src/app/blog/[slug]/page.tsx`), yang merupakan halaman dinamis / menggunakan dynamic route. Buat fungsi generate statics params menggunakan fungsi `getSlugs` tadi di halaman dinamic route slug (`src/app/blog/[slug]/page.tsx`)

  ```tsx
  // src/app/blog/[slug]/page.tsx
  import React from 'react';

  import { getPostBySlug, getSlugs } from '@/libs/post';

  import Heading from '@/components/Heading';
  import ShareLinkButton from '@/components/ShareLinkButton';

  //---------------------------------------------------------------
  export const generateStaticParams = async () => {
    const slugs = await getSlugs();

    return slugs.map((slug) => ({ slug }));
  };
  //---------------------------------------------------------------

  export const generateMetadata = async ({
    params,
  }: {
    params: { slug: string };
  }) {
    const post = await getPostBySlug(params.slug);

    return {
      title: post.title,
      description: post.description,
    };
  }

  const BlogContent = async ({ params }: { params: { slug: string } }) => {
    const post = await getPostBySlug(params.slug);

    return (
      <>
        <Heading>{post.title}</Heading>
        <div className="flex gap-3 pb-2 items-baseline">
          <p className="italic text-sm pb-2">
            {post.date} - {post.author}
          </p>
          <ShareLinkButton />
        </div>
        <img
          src={post.image}
          alt="natural"
          width={640}
          height={360}
          className="mb-2 rounded"
        />
        <article
          dangerouslySetInnerHTML={{ __html: post.body }}
          className="prose max-w-screen-sm text-red-900"
        />
      </>
    );
  };

  export default BlogContent;
  ```

### Persiapan Deploy Project Static Page di Self Hosting

Berikut beberapa persiapan yang harus dilakukan untuk deploy project satatic page di self hosting:

- Tambahkan properti `out: export` di file `next.config.mjs`

  ```mjs
  // next.config.mjs

  /** @type {import('next').NextConfig} */
  const nextConfig = {
    output: 'export',
  };

  export default nextConfig;
  ```

- Kemudian jalankan command `npm run build`, setelah itu akan muncul hasilnya di folder `out`
- Jalankan build di folder `out` bisa menggunakan extensi vs code `liveserver` atau menggunakan packe [serve](https://www.npmjs.com/package/serve) menggunakan command `npx serve@latest out`
- Tambahakan out di file .gitignore agar folder out tidak ikut di-push ke github.
- [Dan ini cara untuk mendeploy project static page di netifly](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10309)

## Manage Project menggunakan Headless CMS (strapi)

### Persiapan Headless CMS (strapi) Untuk Membuat Konten

Berikut langkah - langkah untuk memulai install [strapi](https://strapi.io/) [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10311)

- Buka terminal kemudain install stripe ikuti command di docs [stripe](https://strapi.io/)
- Setelah selesai, lakukan register pada link yang diarahkan oleh stripe di terminal
- Kemudian buat tabel dan column, dengan cara klik menu `Content-Type Builder` di sidebar
- Buatkan content pada column dan tabel yang kita buat tadi secara menual
- Coba akses api url `http://localhost:1337/api/{nama-table}`

### Mengambil Data dari Strapi

Kita akan mencoba melakukan fetch data melalui api dari strapi, menggunakan file `mjs` hanya untuk kebutuhan development (ini bisa langsung skip ke []()):

- Buat file dengan extentsi `.mjs` untuk melakukan fetch data (di contoh dibuat di `src/libs/fetchdata.mjs`) [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10312).
- Tentukan data mana saja yang akan ditampilkan di response dari strapi menggunakan paramater dengan bantuan library yang direkomendasikan oleh strapi yaitu [qs](https://www.npmjs.com/package/@types/qs) [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10313).

  ```mjs
  // src/libs/fetchData.mjs

  import { writeFileSync } from 'node:fs';
  import qs from 'qs';

  const url =
    'http://localhost:1337/api/posts' + // URL dasar untuk API Strapi.
    '?' + // Menambahkan tanda tanya untuk memulai query string.
    qs.stringify(
      {
        // Pilih field yang ingin diambil.
        fields: [
          'slug',
          'title',
          'description',
          'publishedAt',
          'author',
          'body',
        ],
        populate: {
          image: { fields: ['url'] }, // Mengatur agar field 'image' juga diambil dengan field 'url' saja.
        },
        sort: 'publishedAt:desc', // Mengatur urutan hasil berdasarkan tanggal publikasi secara menurun.
        pagination: { pageSize: 1 }, // Mengatur agar hanya 1 item yang diambil per halaman.
      },
      { encodeValuesOnly: true } // Mengatur agar hanya nilai yang di-encode (proses mengubah data dari satu format ke format lain) dalam query string.
    );

  // Mengambil data dari URL yang telah dibuat menggunakan fetch API.
  // await memastikan bahwa program menunggu sampai fetch selesai dan respons diterima.
  const response = await fetch(url);

  // Mengambil isi body dari respons dan mengubahnya menjadi objek JavaScript.
  const body = await response.json();

  // Mengubah objek body menjadi string JSON yang diformat dengan indensi 2 spasi.
  const posts = JSON.stringify(body, null, 2);

  // console.log(posts);

  // Menentukan path file tempat data akan disimpan.
  const file = 'src/libs/postsResponse.json';

  // Menulis string JSON ke dalam file postsResponse.json dengan encoding UTF-8.
  // writeFileSync memastikan penulisan dilakukan secara sinkron.
  writeFileSync(file, posts, 'utf-8');
  ```

- Kemudian command `node src/libs/fetchData.mjs`, karena di contoh code di atas kita menggunakan file `src/libs/postsResponse.json maka buka file tersebut untuk melihat hasilnya.

### Fetch Get All Data menggunaakn API dari Strapi di Server

Berikut langkah - langkah yang harus dilakukan [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10314) [ref2](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10315):

- Buat function untuk melakukan fetch api dari strapi dengan bantuan `qs` yang mengatur parameter untuk menseleksi data apa saja yang akan ditampilkan de response

  ```ts
  // src/libs/post.ts

  import qs from 'qs';

  interface Post {
    title: string;
    description: string;
    image: string;
    date: string;
    author: string;
    body: string | Promise<string>;
    slug: string;
  }

  const BACKEND_URL = 'http://localhost:1337';

  // Fungsi untuk mendapatkan semua konten dari file berextensi .md dari direktori src/contents/blog/
  export const getAllContents = async (): Promise<Post[]> => {
    // Menginisialisasi array untuk menampung post
    const posts: Post[] = [];

    const url =
      `${BACKEND_URL}/api/posts?` +
      // URL dasar untuk API Strapi. Menambahkan tanda tanya untuk memulai query string.
      qs.stringify(
        {
          // Pilih field yang ingin diambil.
          fields: [
            'slug',
            'title',
            'description',
            'publishedAt',
            'author',
            'body',
          ],
          populate: {
            image: { fields: ['url'] }, // Mengatur agar field 'image' juga diambil dengan field 'url' saja.
          },
          sort: 'publishedAt:desc', // Mengatur urutan hasil berdasarkan tanggal publikasi secara menurun.
          pagination: { pageSize: 5 }, // Mengatur agar hanya 1 item yang diambil per halaman.
        },
        { encodeValuesOnly: true } // Mengatur agar hanya nilai yang di-encode (proses mengubah data dari satu format ke format lain) dalam query string.
      );

    // Mengambil data dari URL yang telah dibuat menggunakan fetch API.
    // await memastikan bahwa program menunggu sampai fetch selesai dan respons diterima.
    const response = await fetch(url);
    const { data } = await response.json();
    console.log(data);

    return data?.map(
      ({
        attributes,
      }: {
        attributes: {
          author: string;
          body: string;
          createdAt: string;
          description: string;
          image: {
            data: { attributes: { url: string }; id: number };
          };
          publishedAt: string;
          slug: string;
          title: string;
        };
      }) => ({
        author: attributes.author,
        body: attributes.body,
        description: attributes.description,
        image: BACKEND_URL + attributes.image.data.attributes.url,
        publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
        slug: attributes.slug,
        title: attributes.title,
      })
    );
  };
  ```

- Panggil function fetching itu untuk manampilkan datanya di Ui

  ```tsx
  // src/app/blog/page.tsx

  import Heading from '@/components/Heading';
  import PostCard from '@/components/PostCard';
  import React from 'react';
  import { inter } from '../fonts';
  //------------------------------------------------------------------------------
  import { getAllContents } from '@/libs/post';
  //------------------------------------------------------------------------------

  const BlogPage = async () => {
    //------------------------------------------------------------------------------
    const contens = await getAllContents();
    //------------------------------------------------------------------------------

    return (
      <>
        <Heading>Blog Page</Heading>
        <h2 className={`text-2xl mb-3 ${inter.className}`}>List of Post</h2>
        {contens?.map((content, index) => (
          <PostCard
            key={index}
            author={content.author}
            date={content.date}
            description={content.description}
            href={`/blog/${content.slug}`}
            image={content.image}
            title={content.title}
          />
        ))}
      </>
    );
  };

  export default BlogPage;
  ```

### Fetch Get Data by Slug

berikut cara code untuk melakukan fetch get data by slug di server [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10317)

```tsx
// src/libs/posts.ts

import { marked } from 'marked';
import qs from 'qs';

export const getPostBySlug = async (slug: string): Promise<Post> => {
  const url =
    `${BACKEND_URL}/api/posts?` +
    qs.stringify(
      {
        filters: {
          slug: {
            $eq: slug,
          },
        },
        fields: [
          'author',
          'body',
          'description',
          'publishedAt',
          'slug',
          'title',
        ],
        populate: {
          image: { fields: ['url'] },
        },
      },
      { encodeValuesOnly: true }
    );

  const response = await fetch(url);
  const { data } = await response.json();
  const { attributes } = data[0];

  console.log('post', attributes);

  return {
    author: attributes.author,
    body: marked(attributes?.body),
    description: attributes.description,
    image: BACKEND_URL + attributes.image.data.attributes.url,
    publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
    slug: attributes.slug,
    title: attributes.title,
  };
};
```

### Refactor Code Fetch Get Post By Slug dan Get All Posts

Refactor di lakukan dengan memisahkan code yang bertugas melakukan fetch dari api strapi menjadi function yang terpisah [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10318), Sehingga code yang awalnya seperti ini:

```ts
// src/libs/post.ts
import { readdir } from 'fs/promises';
import path from 'path';
import { marked } from 'marked';
import qs from 'qs';

interface Post {
  author: string;
  body: string | Promise<string>;
  description: string;
  image: string;
  publishedAt: string;
  slug: string;
  title: string;
}

const BACKEND_URL = 'http://localhost:1337';

export const getPostBySlug = async (slug: string): Promise<Post> => {
  const url =
    `${BACKEND_URL}/api/posts?` +
    qs.stringify(
      {
        filters: {
          slug: {
            $eq: slug,
          },
        },
        fields: [
          'author',
          'body',
          'description',
          'publishedAt',
          'slug',
          'title',
        ],
        populate: {
          image: { fields: ['url'] },
        },
      },
      { encodeValuesOnly: true }
    );

  const response = await fetch(url);
  const { data } = await response.json();
  const { attributes } = data[0];

  console.log(
    'responseniiiii',
    BACKEND_URL + attributes.image.data.attributes.url
  );

  return {
    author: attributes.author,
    body: marked(attributes?.body),
    description: attributes.description,
    image: BACKEND_URL + attributes.image.data.attributes.url,
    publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
    slug: attributes.slug,
    title: attributes.title,
  };
};

export const getAllContents = async (): Promise<Post[]> => {
  const url =
    `${BACKEND_URL}/api/posts?` +
    // URL dasar untuk API Strapi. Menambahkan tanda tanya untuk memulai query string.
    qs.stringify(
      {
        // Pilih field yang ingin diambil.
        fields: ['author', 'description', 'publishedAt', 'slug', 'title'],
        populate: {
          image: { fields: ['url'] }, // Mengatur agar field 'image' juga diambil dengan field 'url' saja.
        },
        sort: 'publishedAt:desc', // Mengatur urutan hasil berdasarkan tanggal publikasi secara menurun.
        pagination: { pageSize: 5 }, // Mengatur agar hanya 1 item yang diambil per halaman.
      },
      { encodeValuesOnly: true } // Mengatur agar hanya nilai yang di-encode (proses mengubah data dari satu format ke format lain) dalam query string.
    );

  // Mengambil data dari URL yang telah dibuat menggunakan fetch API.
  // await memastikan bahwa program menunggu sampai fetch selesai dan respons diterima.
  const response = await fetch(url);
  const { data } = await response.json();
  // console.log(data);

  return data?.map(
    ({
      attributes,
    }: {
      attributes: {
        author: string;
        createdAt: string;
        description: string;
        image: {
          data: { attributes: { url: string }; id: number };
        };
        publishedAt: string;
        slug: string;
        title: string;
      };
    }) => ({
      author: attributes.author,
      description: attributes.description,
      image: BACKEND_URL + attributes.image.data.attributes.url,
      publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
      slug: attributes.slug,
      title: attributes.title,
    })
  );
};

export const getSlugs = async (): Promise<string[]> => {
  // Membaca file dari direktori src/contents/blog
  const files = await readdir(path.join(process.cwd(), './src/contents/blog'));

  // Memfilter file yang berakhiran .md dan hapus ekstensi .md untuk mendapatkan slug
  const slugs = files
    .filter((file) => file.endsWith('.md'))
    .map((file) => file.slice(0, -'.md'.length));

  return slugs;
};
```

Hasilnya jadi seperti ini

```ts
import { readdir } from 'fs/promises';
import path from 'path';
import { marked } from 'marked';
import qs from 'qs';

interface Post {
  author: string;
  body: string | Promise<string>;
  description: string;
  image: string;
  publishedAt: string;
  slug: string;
  title: string;
}

interface FetchPostsParameters {
  filters?: {
    slug?: {
      $eq: string;
    };
  };
  fields?: string[];
  populate?: {
    image?: {
      fields?: string[];
    };
  };
  sort?: string[];
  pagination?: {
    pageSize?: number;
  };
}

const BACKEND_URL = 'http://localhost:1337';

export const getPostBySlug = async (slug: string): Promise<Post> => {
  const { data } = await fetchPosts({
    filters: {
      slug: {
        $eq: slug,
      },
    },
    fields: ['author', 'body', 'description', 'publishedAt', 'slug', 'title'],
    populate: {
      image: { fields: ['url'] },
    },
  });

  const { attributes } = data[0];
  // console.log('attributes', attributes);

  return {
    author: attributes.author,
    body: marked(attributes?.body),
    description: attributes.description,
    image: BACKEND_URL + attributes.image.data.attributes.url,
    publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
    slug: attributes.slug,
    title: attributes.title,
  };
};

export const getAllContents = async (): Promise<Post[]> => {
  const { data } = await fetchPosts({
    fields: ['author', 'body', 'description', 'publishedAt', 'slug', 'title'],
    populate: { image: { fields: ['url'] } },
    sort: ['publishedAt:desc'],
    pagination: { pageSize: 3 },
  });

  // console.log(data);

  return data?.map(
    ({
      attributes,
    }: {
      attributes: {
        author: string;
        createdAt: string;
        description: string;
        image: {
          data: { attributes: { url: string }; id: number };
        };
        publishedAt: string;
        slug: string;
        title: string;
      };
    }) => ({
      author: attributes.author,
      description: attributes.description,
      image: BACKEND_URL + attributes.image.data.attributes.url,
      publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
      slug: attributes.slug,
      title: attributes.title,
    })
  );
};

export const getSlugs = async (): Promise<string[]> => {
  // Membaca file dari direktori src/contents/blog
  const files = await readdir(path.join(process.cwd(), './src/contents/blog'));

  // Memfilter file yang berakhiran .md dan hapus ekstensi .md untuk mendapatkan slug
  const slugs = files
    .filter((file) => file.endsWith('.md'))
    .map((file) => file.slice(0, -'.md'.length));

  return slugs;
};

// Function untuk Melakukan Fetch Post (kontent post) dari api strapi
async function fetchPosts(parameters: FetchPostsParameters) {
  const url =
    `${BACKEND_URL}/api/posts?` +
    qs.stringify(parameters, { encodeValuesOnly: true });

  const response = await fetch(url);

  return await response.json();
}
```

### Generate Agar Project Kita Menjadi Static Page [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10319)

Berikut langakah - langkah untuk melakukan generate agar project kita jadi static page:

- Pastikan kita di file `next.config.mjs` kita sudah menambahkan properti `output: 'export'`

  ```mjs
  /** @type {import('next').NextConfig} */
  const nextConfig = {
    //-------------------------------
    output: 'export',
    //-------------------------------
    images: {
      remotePatterns: [
        {
          protocol: 'http',
          hostname: 'localhost',
          port: '1337',
          pathname: '/uploads/**',
        },
      ],
    },
  };

  export default nextConfig;
  ```

- Ubah function `getSlugs` yang awal nya slugs diambil dari seluruh conent file `md` di folder `contents/blog`

```ts
export const getSlugs = async (): Promise<string[]> => {
  // Membaca file dari direktori src/contents/blog
  const files = await readdir(path.join(process.cwd(), './src/contents/blog'));

  // Memfilter file yang berakhiran .md dan hapus ekstensi .md untuk mendapatkan slug
  const slugs = files
    .filter((file) => file.endsWith('.md'))
    .map((file) => file.slice(0, -'.md'.length));

  return slugs;
};
```

Jadi seperti ini (slugs di ambil dari parameter seluruh content yang menggunakan dynamic route)

```ts
// src/libs/post.ts

export const getSlugs = async (): Promise<string[]> => {
  const { data } = await fetchPosts({
    fields: ['slug'],
    pagination: { pageSize: 100 }, // Adjust pageSize as necessary
  });

  return data.map((post: any) => post.attributes.slug);
};
```

- Pastikan kita sudah menambahkan function `generateStaticParams` di file yang menggunakan dynamic route dengan memanfaatkan function `getSlugs` tadi untuk menghasilkan parameter statis yang diperlukan untuk membuat static page pada aplikasi Next.js (merubah halaman yang dynamic tersebut jadi static pages).

  ```ts
  export const generateStaticParams = async () => {
    const slugs = await getSlugs();

    return slugs.map((slug) => ({ slug }));
  };
  ```

- Jika menggunakan gambar, tambahkan properti `unoptimizend={true}` di elemen Next Image untuk membuat Next Image mengambil gambar langsung dari URL yang Anda tentukan tanpa melakukan optimasi. Misalnya kita meletakkan gambar kita di server tanpa properti tersebut next image akan mengakses url `http://localhost:3000/_next/image?url=http://localhost:1337/uploads/pecel_lele_7a180f1974.jpeg&w=640&q=75`. Dengan adanya properti tersebut Next Image akan mengakses url `http://localhost:1337/uploads/pecel_lele_7a180f1974.jpeg&w=640&q=75`

  ```tsx
  <Image
    src={post.image}
    alt="natural"
    width={640}
    height={360}
    className="mb-2 rounded"
    //-------------------------
    unoptimized={true}
    //-------------------------
  />
  ```

- Jalankan command `npm run build`
- Terakhir command `npx serve@latest output`, tetapi sebelumnya kita harus menginstall [serve](https://www.npmjs.com/package/serve) terlebih dahulu.

## Proses Optimize Next Image [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10322)

## Mengenal Fungsi Dynamic Parameter [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10323)

## Mengenal Fungsi Force Dynamic Pada Component

Saat kita mencoba menggunakan Fungsi Force Dynamic [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10324), Setelah melkukan command `npm run build` dan `npm start` kita mengalami masalah di mana data yang kita upadte di API tidak langsung bisa berubah UI kita. Solusinya kita bisa menambahkan opsi `cache: 'no-store'` ke fetch request kita yaitu di fetch `getAllContents` dan `getPostBySlug`.

```ts
import { marked } from 'marked';
import qs from 'qs';

interface Post {
  author: string;
  body: string | Promise<string>;
  description: string;
  image: string;
  publishedAt: string;
  slug: string;
  title: string;
}

interface FetchPostsParameters {
  filters?: {
    slug?: {
      $eq: string;
    };
  };
  fields?: string[];
  populate?: {
    image?: {
      fields?: string[];
    };
  };
  sort?: string[];
  pagination?: {
    pageSize?: number;
  };
}

const BACKEND_URL = 'http://localhost:1337';

export const getPostBySlug = async (slug: string): Promise<Post> => {
  const { data } = await fetchPosts({
    filters: {
      slug: {
        $eq: slug,
      },
    },
    fields: ['author', 'body', 'description', 'publishedAt', 'slug', 'title'],
    populate: {
      image: { fields: ['url'] },
    },
  });

  const { attributes } = data[0];
  // console.log('attributes', attributes);

  return {
    author: attributes.author,
    body: marked(attributes?.body),
    description: attributes.description,
    image: BACKEND_URL + attributes.image.data.attributes.url,
    publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
    slug: attributes.slug,
    title: attributes.title,
  };
};

export const getAllContents = async (): Promise<Post[]> => {
  const { data } = await fetchPosts({
    fields: ['author', 'body', 'description', 'publishedAt', 'slug', 'title'],
    populate: { image: { fields: ['url'] } },
    sort: ['publishedAt:desc'],
    pagination: { pageSize: 100 },
  });

  // console.log(data);

  return data?.map(
    ({
      attributes,
    }: {
      attributes: {
        author: string;
        createdAt: string;
        description: string;
        image: {
          data: { attributes: { url: string }; id: number };
        };
        publishedAt: string;
        slug: string;
        title: string;
      };
    }) => ({
      author: attributes.author,
      description: attributes.description,
      image: BACKEND_URL + attributes.image.data.attributes.url,
      publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
      slug: attributes.slug,
      title: attributes.title,
    })
  );
};

export const getSlugs = async (): Promise<string[]> => {
  const { data } = await fetchPosts({
    fields: ['slug'],
    pagination: { pageSize: 100 }, // Adjust pageSize as necessary
  });

  return data.map((post: any) => post.attributes.slug);
};

// Function untuk Melakukan Fetch Post (kontent post) dari api strapi
async function fetchPosts(parameters: FetchPostsParameters) {
  const url =
    `${BACKEND_URL}/api/posts?` +
    qs.stringify(parameters, { encodeValuesOnly: true });

  // --------------------------------------------------------------
  const response = await fetch(url, { cache: 'no-store' });
  // --------------------------------------------------------------

  return await response.json();
}
```

## Menampilkan Halaman not Found

Halaman not found dapat dicustome dengan membuat file bernama `not-found.jsx` atau `not-found.tsx` [ref](https://www.youtube.com/watch?v=UyIe8Tqjuq8&t=40m06s). Berikut beberapa langkah untuk melakukan custom halaman not found [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10325):

- Misalnya kita ingin mengakses halaman blog yang mana conentnya belum terdaftar di api kita, mulai dengan menambahkan logic untuk kondisi ketika data yang diakses user tidak ada. Misalnya user mengakses `baseDomain.com/blog/dferereres`, jelas tidak ada di database kita. Tambahkan logic berikut di function `getPostBySlug`:

  ```ts
  // src/libs/post.ts
  export const getPostBySlug = async (slug: string): Promise<Post | null> => {
    const { data } = await fetchPosts(
      {
        filters: {
          slug: {
            $eq: slug,
          },
        },
        fields: [
          'author',
          'body',
          'description',
          'publishedAt',
          'slug',
          'title',
        ],
        populate: {
          image: { fields: ['url'] },
        },
      },
      true // noCache is set to true
    );

    //-----------------------------------------------------------------------------------------
    if (!data || data.length === 0) {
      return null;
    }
    //-----------------------------------------------------------------------------------------

    const { attributes } = data[0];

    return {
      author: attributes.author,
      body: marked(attributes?.body),
      description: attributes.description,
      image: BACKEND_URL + attributes.image.data.attributes.url,
      publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
      slug: attributes.slug,
      title: attributes.title,
    };
  };
  ```

- Kemudian tambahkah logic juga di page yang menampilkan data post tersebut yaitu di page kontent blog `src/app/blog/[slug]/page.tsx`

  ```tsx
  // src/app/blog/[slug]/page.tsx
  import React from 'react';

  import { getPostBySlug, getSlugs } from '@/libs/post';

  import Heading from '@/components/Heading';
  import ShareLinkButton from '@/components/ShareLinkButton';
  import Image from 'next/image';
  import { notFound } from 'next/navigation';

  export const dynamic = 'force-dynamic';

  // export const generateStaticParams = async () => {
  //   const slugs = await getSlugs();

  //   return slugs.map((slug) => ({ slug }));
  // };

  export async function generateMetadata({
    params,
  }: {
    params: { slug: string };
  }) {
    const post = await getPostBySlug(params.slug);

    if (!post) {
      return { title: 'Post Not Found', description: '' };
    }

    return {
      title: post.title,
      description: post.description,
    };
  }

  const BlogContent = async ({ params }: { params: { slug: string } }) => {
    const post = await getPostBySlug(params.slug);

    if (!post) {
      //------------------------------------------------------------------------------------
      notFound();
      //------------------------------------------------------------------------------------
    }
    return (
      <>
        <Heading>{post.title}</Heading>
        <div className="flex gap-3 pb-2 items-baseline">
          <p className="italic text-sm pb-2">
            {post.publishedAt} - {post.author}
          </p>
          <ShareLinkButton />
        </div>
        <Image
          src={post.image}
          alt="natural"
          width={640}
          height={360}
          className="mb-2 rounded"
          // unoptimized={true}
        />
        <article
          dangerouslySetInnerHTML={{ __html: post.body }}
          className="prose max-w-screen-sm text-red-900"
        />
      </>
    );
  };

  export default BlogContent;
  ```

## Mengenal Revalidate untuk Fetch Data

[Revalidate](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#revalidate) adalah proses di mana Next.js akan melakukan fetch data ke cache terlebih dahalu (sesuai setingan), jika kita menambahkan angka sebagai valuenya maka setelah beberapa detik sesuai dengan value yang diinputkan maka Next.js akan melakukan fetch ke api untuk mengambil data terbaru. Berikut langakah - langkah yang perlu dipersiapkan agar kita bisa melakukan revalidate [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10326):

- Tambahkan option revalidate ke page yang ingin diterapkan (di contoh ini di page blog (`src/app/blog/page.tsx`) dan page konten blog (`src/app/blog/[slug]/page.tsx`)) dan juga tambahkan function `generateStaticParams` di page yang menerapkan dynamic route.

  - Page blog (`src/app/blog/page.tsx`)

    ```tsx
    import Heading from '@/components/Heading';
    import PostCard from '@/components/PostCard';
    import React from 'react';
    import { inter } from '../fonts';
    import { getAllContents } from '@/libs/post';

    //---------------------------------------------------------------------------------
    export const revalidate = 30;
    //---------------------------------------------------------------------------------

    const BlogPage = async () => {
      const contens = await getAllContents();

      return (
        <>
          <Heading>Blog Page</Heading>
          <h2 className={`text-2xl mb-3 ${inter.className}`}>List of Post</h2>
          {contens?.map((content, index) => (
            <PostCard
              key={index}
              author={content.author}
              description={content.description}
              image={content.image}
              publishedAt={content.publishedAt}
              slug={`/blog/${content.slug}`}
              title={content.title}
            />
          ))}
        </>
      );
    };

    export default BlogPage;
    ```

  - Konten blog (`src/app/blog/[slug]/page.tsx`)

    ```tsx
    import React from 'react';

    import { getPostBySlug, getSlugs } from '@/libs/post';

    import Heading from '@/components/Heading';
    import ShareLinkButton from '@/components/ShareLinkButton';
    import Image from 'next/image';
    import { notFound } from 'next/navigation';

    //-------------------------------------------------------------------------
    export const revalidate = 30;

    // Function yang digunakan untuk mendapatkan static page
    export const generateStaticParams = async () => {
      const slugs = await getSlugs();

      return slugs.map((slug) => ({ slug }));
    };
    //-------------------------------------------------------------------------

    export async function generateMetadata({
      params,
    }: {
      params: { slug: string };
    }) {
      const post = await getPostBySlug(params.slug);

      if (!post) {
        return { title: 'Post Not Found', description: '' };
      }

      return {
        title: post.title,
        description: post.description,
      };
    }

    const BlogContent = async ({ params }: { params: { slug: string } }) => {
      const post = await getPostBySlug(params.slug);

      if (!post) {
        notFound();
      }
      return (
        <>
          <Heading>{post.title}</Heading>
          <div className="flex gap-3 pb-2 items-baseline">
            <p className="italic text-sm pb-2">
              {post.publishedAt} - {post.author}
            </p>
            <ShareLinkButton />
          </div>
          <Image
            src={post.image}
            alt="natural"
            width={640}
            height={360}
            className="mb-2 rounded"
            // unoptimized={true}
          />
          <article
            dangerouslySetInnerHTML={{ __html: post.body }}
            className="prose max-w-screen-sm text-red-900"
          />
        </>
      );
    };

    export default BlogContent;
    ```

- Hapus folder `.next` dan jalankan command `npm run build`
- Jalankan `npm start` untuk menjalankan project

## Menggunakan Force Update Dan Revalidate Di Fetch

Kita bisa menggunaan Force Update dan Revalidate di Function fetch kita [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10327). Caranya tinggal kita tambahkah `cache:'no-store'` atau `next: { revalidate: 30 }` di parameter function fetch kita seperti ini:

```ts
// src/libs/post.ts

async function fetchPosts(
  parameters: FetchPostsParameters,
  noCache: boolean = false
) {
  const url =
    `${BACKEND_URL}/api/posts?` +
    qs.stringify(parameters, { encodeValuesOnly: true });

  const response = await fetch(url, {
    cache: noCache ? 'no-store' : 'default',
    // next: { revalidate: 30 },
  });

  return await response.json();
}
```

## Membuat Fitur pagination

Pada contoh ini kita akan membuat fitur pagination untuk page Blog (`src/app/blog/page.tsx`). Jadi kita akan fokus ke file page blog tersebut, file tempat kita melakukan fetch data content post (`src/libs/post`) dan file component pagination yang akan kita buat nanti. Berikut langkah - langkah untuk membuat fitur pagination dengan fetch data dari strapi API:

- Tangkap data query parameter untuk Pagination [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10330). <br/>

  - Ambil data query param yang ada di prop component BogPage dan tampilkan nilainya untuk menunjukkan user sedang di halaman berapa dan buat tombol handle untuk mengurangi dan menambahkan halaman guna berpindah halaman menggunakan element `Link` Next.js dengan properti href yang ditujukan ke query params.

    ```tsx
    import React from 'react';
    import Link from 'next/link';
    import { inter } from '../fonts';

    import { getAllContents } from '@/libs/post';

    import Heading from '@/components/Heading';
    import PostCard from '@/components/PostCard';

    export const revalidate = 30;

    const BlogPage = async (params: {
      params: Record<string, string>;
      searchParams: {
        page?: string;
      };
    }) => {
      //----------------------------------------------------------
      console.log(params); // { params: {}, searchParams: { page: '3' } }

      const page = params.searchParams.page
        ? parseInt(params.searchParams.page)
        : 1;
      //----------------------------------------------------------

      const contens = await getAllContents();

      return (
        <>
          <Heading>Blog Page</Heading>
          <h2 className={`text-2xl mb-3 ${inter.className}`}>List of Post</h2>
          //----------------------------------------------------------
          <div className="flex gap-3 pb-2">
            <Link href={''}>&lt;</Link>
            <span>Page 1</span>
            <Link href={'/blog?page=2'}>&gt;</Link>
          </div>
          //----------------------------------------------------------
          {contens?.map((content, index) => (
            <PostCard
              key={index}
              author={content.author}
              description={content.description}
              image={content.image}
              publishedAt={content.publishedAt}
              slug={`/blog/${content.slug}`}
              title={content.title}
            />
          ))}
        </>
      );
    };

    export default BlogPage;
    ```

  - Buat function untuk melakukan parse query params page dari string dari string ke integer dan logic jika

    ```tsx
    import React from 'react';
    import Link from 'next/link';
    import { inter } from '../fonts';

    import { getAllContents } from '@/libs/post';

    import Heading from '@/components/Heading';
    import PostCard from '@/components/PostCard';

    export const revalidate = 30;

    const BlogPage = async (params: {
      params: Record<string, string>;
      searchParams: {
        page?: string;
      };
    }) => {
      // console.log(params); // { params: {}, searchParams: { page: '3' } }

      //-------------------------------------------------------------
      const page = parsePageParam(params.searchParams.page);
      //-------------------------------------------------------------

      const contens = await getAllContents();

      return (
        <>
          <Heading>Blog Page</Heading>
          <h2 className={`text-2xl mb-3 ${inter.className}`}>List of Post</h2>

          <div className="flex gap-3 pb-2">
            <Link href={''}>&lt;</Link>
            <span>Page 1</span>
            <Link href={'/blog?page=2'}>&gt;</Link>
          </div>

          {contens?.map((content, index) => (
            <PostCard
              key={index}
              author={content.author}
              description={content.description}
              image={content.image}
              publishedAt={content.publishedAt}
              slug={`/blog/${content.slug}`}
              title={content.title}
            />
          ))}
        </>
      );
    };

    export default BlogPage;

    //-------------------------------------------------------------
    const parsePageParam = (paramValue: string | undefined) => {
      if (paramValue) {
        const page = parseInt(paramValue);

        if (isFinite(page) && page > 0) {
          return page;
        }
      }
      return 1;
    };
    //-------------------------------------------------------------
    ```

- Gunakan Parameter [Pagination Strapi](https://docs.strapi.io/dev-docs/api/rest/sort-pagination) untuk mendapatkan data pagination termasuk nilai total page dan value yang menunjukkan sekarang user berada di halaman berapa [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10331) [ref2](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10332)<br/>

  - Di file `src/libs/post.ts` (tempat kita melakukan fetc api) Ubah parameter function `getAllContents` tambahkan value `page` untuk menunjukkan user sedang berada di halaman berapa. Ubah value `pageSize` dand value `page` tadi dinamis, jadikan paremeter di function `getAllContents` tersebut. Kemudian ubah return pada function `getAllContents` ini yang semula hanya mereturn value array `contents` jadi mereturn `contents` dan `meta` (data pagination). Untuk mengikuti perubahan tersebut kita harus melakukan perubahan - perubahan berikut:

    - Ubah type `FetchPostsParameters`, tambahkan value page
    - Tambahkan type `meta` Untuk menunjukkan data pagination

    ```ts
    import { marked } from 'marked';
    import qs from 'qs';

    interface Post {
      author: string;
      body: string | Promise<string>;
      description: string;
      image: string;
      publishedAt: string;
      slug: string;
      title: string;
    }

    //----------------------------------------------------------------------
    interface Meta {
      pagination: {
        page: number;
        pageSize: number;
        pageCount: number;
        total: number;
      };
    }
    //----------------------------------------------------------------------

    interface FetchPostsParameters {
      filters?: {
        slug?: {
          $eq: string;
        };
      };
      fields?: string[];
      populate?: {
        image?: {
          fields?: string[];
        };
      };
      sort?: string[];
      pagination?: {
        pageSize?: number;
        //----------------------------------------------------------------------
        page?: number;
        //----------------------------------------------------------------------
      };
    }

    const BACKEND_URL = 'http://localhost:1337';
    export const CACHE_TAG_POSTS = 'posts';

    export const getPostBySlug = async (slug: string): Promise<Post | null> => {
      const { data } = await fetchPosts(
        {
          filters: {
            slug: {
              $eq: slug,
            },
          },
          fields: [
            'author',
            'body',
            'description',
            'publishedAt',
            'slug',
            'title',
          ],
          populate: {
            image: { fields: ['url'] },
          },
        }
        // true // noCache is set to true
      );

      if (!data || data.length === 0) {
        return null;
      }

      const { attributes } = data[0];

      return {
        author: attributes.author,
        body: marked(attributes?.body),
        description: attributes.description,
        image: BACKEND_URL + attributes.image.data.attributes.url,
        publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
        slug: attributes.slug,
        title: attributes.title,
      };
    };

    //----------------------------------------------------------------------
    export const getAllContents = async (
      pageSize: number,
      page: number
    ): Promise<{ meta: Meta; contents: Post[] }> => {
      const { data, meta } = await fetchPosts(
        {
          fields: [
            'author',
            'body',
            'description',
            'publishedAt',
            'slug',
            'title',
          ],
          populate: { image: { fields: ['url'] } },
          sort: ['updatedAt:desc'],
          pagination: { pageSize, page },
        }
        // false // noCache is set to false
      );

      // console.log(data);

      return {
        meta: meta,
        contents: data?.map(
          ({
            attributes,
          }: {
            attributes: {
              author: string;
              createdAt: string;
              description: string;
              image: {
                data: { attributes: { url: string }; id: number };
              };
              publishedAt: string;
              slug: string;
              title: string;
            };
          }) => ({
            author: attributes.author,
            description: attributes.description,
            image: BACKEND_URL + attributes.image.data.attributes.url,
            publishedAt: attributes.publishedAt.slice(0, 'yyyy-mm-dd'.length),
            slug: attributes.slug,
            title: attributes.title,
          })
        ),
      };
    };
    //----------------------------------------------------------------------

    export const getSlugs = async (): Promise<string[]> => {
      const { data } = await fetchPosts({
        fields: ['slug'],
        pagination: { pageSize: 3 }, // Adjust pageSize as necessary
      });

      return data.map((post: any) => post.attributes.slug);
    };

    // Function untuk Melakukan Fetch Post (kontent post) dari api strapi
    async function fetchPosts(
      parameters: FetchPostsParameters
      // noCache: boolean = false
    ) {
      const url =
        `${BACKEND_URL}/api/posts?` +
        qs.stringify(parameters, { encodeValuesOnly: true });

      const response = await fetch(url, {
        // cache: noCache ? 'no-store' : 'default',
        // next: { revalidate: 30 },
        next: {
          tags: [CACHE_TAG_POSTS],
        },
      });

      return await response.json();
    }
    ```

  - Di page blog (`src/app/blog/page.tsx`), tambahkan value parameter `pageSize` dan `page` di function `getAllContents` kemudian ambil nilai meta (data pagination) dan contents dan tampilkan di UI

    ```tsx
    import Heading from '@/components/Heading';
    import PostCard from '@/components/PostCard';
    import React from 'react';
    import Link from 'next/link';
    import { inter } from '../fonts';
    import { getAllContents } from '@/libs/post';

    export const revalidate = 30;

    const BlogPage = async (params: {
      params: Record<string, string>;
      searchParams: {
        page?: string;
      };
    }) => {
      // console.log(params); // { params: {}, searchParams: { page: '3' } }

      const page = parsePageParam(params.searchParams.page);
      //----------------------------------------------------------------------------------
      const { meta, contents } = await getAllContents(3, page);
      //----------------------------------------------------------------------------------

      return (
        <>
          <Heading>Blog Page</Heading>
          <h2 className={`text-2xl mb-3 ${inter.className}`}>List of Post</h2>

          <div className="flex gap-3 pb-2">
            <Link href={`/blog?page=${page - 1}`}>&lt;</Link>
            <span>
              //----------------------------------------------------------------------------------
              Page {page} of {meta.pagination.pageCount}
              //----------------------------------------------------------------------------------
            </span>
            <Link href={`/blog?page=${page + 1}`}>&gt;</Link>
          </div>

          {contents?.map((content, index: number) => (
            <PostCard
              key={index}
              author={content.author}
              description={content.description}
              image={content.image}
              publishedAt={content.publishedAt}
              slug={`/blog/${content.slug}`}
              title={content.title}
            />
          ))}
        </>
      );
    };

    export default BlogPage;

    const parsePageParam = (paramValue: string | undefined) => {
      if (paramValue) {
        const page = parseInt(paramValue);

        if (isFinite(page) && page > 0) {
          return page;
        }
      }
      return 1;
    };
    ```

- Pisahkan component pagination dan buat logic batas page ketika user berada di halaman awal dan akhir [ref](https://dashboard.codepolitan.com/learn/courses/belajar-nextjs-dengan-headless-cms/lessons/10333)

  ```tsx
  // src/components/Pagination.tsx

  import { ChevronRightIcon } from '@heroicons/react/24/outline';
  import { ChevronLeftIcon } from '@heroicons/react/24/outline';
  import Link from 'next/link';
  import React from 'react';

  const Pagination = ({
    href,
    page,
    pageCount,
  }: {
    href: string;
    page: number;
    pageCount: number;
  }) => {
    return (
      <div className="flex gap-3 pb-3">
        <PaginationLink enabled={page > 1} href={`${href}?page=${page - 1}`}>
          <ChevronLeftIcon className="w-4 h-4" />
        </PaginationLink>
        <span>
          Page {page} of {pageCount}
        </span>
        <Link href={`${href}?page=${page + 1}`}>&gt;</Link>
        <PaginationLink
          enabled={page < pageCount}
          href={`${href}?page=${page + 1}`}
        >
          <ChevronRightIcon className="h-4 w-4" />
        </PaginationLink>
      </div>
    );
  };

  export default Pagination;

  const PaginationLink = ({
    children,
    enabled,
    href,
  }: {
    children: React.ReactNode;
    enabled: boolean;
    href: string;
  }) => {
    if (!enabled) {
      return (
        <span className="px-3 py-1 rounded border border-gray-300 cursor-not-allowed">
          {children}
        </span>
      );
    }
    return (
      <Link
        href={href}
        className="px-3 py-1 rounded border border-gray-300 hover:bg-gray-200"
      >
        {children}
      </Link>
    );
  };
  ```

  ```tsx
  import Heading from '@/components/Heading';
  import PostCard from '@/components/PostCard';
  import React from 'react';
  import { inter } from '../fonts';
  import { getAllContents } from '@/libs/post';
  import Link from 'next/link';
  import Pagination from '@/components/Pagination';

  export const revalidate = 30;

  const BlogPage = async (params: {
    params: Record<string, string>;
    searchParams: {
      page?: string;
    };
  }) => {
    // console.log(params); // { params: {}, searchParams: { page: '3' } }

    const page = parsePageParam(params.searchParams.page);

    const { meta, contents } = await getAllContents(3, page);
    console.log('post', meta);

    return (
      <>
        <Heading>Blog Page</Heading>
        <h2 className={`text-2xl mb-3 ${inter.className}`}>List of Post</h2>
        //------------------------------------------------------------------------------
        <Pagination
          href={'/blog'}
          page={page}
          pageCount={meta.pagination.pageCount}
        />
        //------------------------------------------------------------------------------
        {contents?.map((content, index: number) => (
          <PostCard
            key={index}
            author={content.author}
            description={content.description}
            image={content.image}
            publishedAt={content.publishedAt}
            slug={`/blog/${content.slug}`}
            title={content.title}
          />
        ))}
      </>
    );
  };

  export default BlogPage;

  const parsePageParam = (paramValue: string | undefined) => {
    if (paramValue) {
      const page = parseInt(paramValue);

      if (isFinite(page) && page > 0) {
        return page;
      }
    }
    return 1;
  };
  ```

## Layout Management

App Router mendukung pengaturan layout yang lebih kompleks dan nested layout. Layout merupakan UI yang dishare ke multiple component.

#### Layout Sederhana

```jsx
// components/Layout.js
const Layout = ({ children }) => {
  return (
    <div>
      <header>
        <h1>My App</h1>
        <nav>
          <a href="/">Home</a>
          <a href="/about">About</a>
        </nav>
      </header>
      <main>{children}</main>
      <footer>
        <p>&copy; 2024 My App</p>
      </footer>
    </div>
  );
};

export default Layout;
```

#### Menggunakan Layout di Halaman

```jsx
// pages/_app.js
import Layout from '../components/Layout';

function MyApp({ Component, pageProps }) {
  return (
    <Layout>
      <Component {...pageProps} />
    </Layout>
  );
}

export default MyApp;
```

#### Nested Layout

Untuk layout bersarang, Anda dapat menggunakan komponen layout di dalam komponen halaman lainnya.

```jsx
// components/DashboardLayout.js
const DashboardLayout = ({ children }) => {
  return (
    <div>
      <aside>
        <nav>
          <a href="/dashboard">Overview</a>
          <a href="/dashboard/settings">Settings</a>
        </nav>
      </aside>
      <section>{children}</section>
    </div>
  );
};

export default DashboardLayout;
```

```jsx
// pages/dashboard.js
import DashboardLayout from '../components/DashboardLayout';

const Dashboard = () => {
  return (
    <DashboardLayout>
      <h1>Dashboard Overview</h1>
    </DashboardLayout>
  );
};

export default Dashboard;
```

## Template

template dibahas lebih lanjut [di sini](https://www.youtube.com/watch?v=UyIe8Tqjuq8&t=1h37m59)

## Membuat UI Loading

Untuk membuat tampilan loading, kita bisa buat file bernama `loading.tsx` di dalam folder `app`.

```tsx
// src/app/loading.tsx

import React from 'react';

const Loading = () => {
  return <div>Loading..............</div>;
};

export default Loading;
```

Kita juga bisa membuat UI lodaing tersendiri untuk setiap folder atau route lainnya. Caranya tinggal buat file `loading.tsx` di folder yang ingin dibuat loadingnya sendiri, sehingga akan jadi seperti ini contoh struktur foldernya

```tsx
src/app/

|-- product
|   |-- [productId]/
|   |   |-- reviews/
|   |   |   |-- [reviewId]
|   |   |   |   |-- page.tsx
|   |   |-- page.tsx
|   |-- loading.tsx
|   |-- page.tsx
|-- layout.tsx
|-- loading.tsx
|-- not-found.tsx
|-- page.tsx
```

## 404 Page / Not Found Page

Di Next.js, menangani halaman Not Found (404) bisa dilakukan dengan mudah. Halaman Not Found adalah halaman yang ditampilkan ketika pengguna mencoba mengakses URL yang tidak ada di route aplikasi kita. Halaman not found ini harus dibuat di file di folder app dengan nama `not-found.jsx` atau `not-found.tsx`. Berikut struktur file aplikasi jika ditambahkan halaman not found:

```tsx
src/app/

|-- product
|   |-- [productId]/
|   |   |-- reviews/
|   |   |   |-- [reviewId]
|   |   |   |   |-- page.tsx
|   |   |-- page.tsx
|   |-- page.tsx
|-- layout.tsx
|-- not-found.tsx
|-- page.tsx
```

Berikut contoh code halaman not-found `src/app/not-found`

```tsx
import Link from 'next/link';
import React from 'react';

const NotFound = () => {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-6xl font-bold">404</h1>
      <p className="mt-4 text-xl">
        Oops! The page you're looking for doesn't exist.
      </p>
      <Link
        href="/"
        className="mt-6 px-4 py-2 text-lg text-white bg-blue-500 rounded hover:bg-blue-600"
      >
        Go back to Home
      </Link>
    </div>
  );
};

export default NotFound;
```

### Menangani Halaman Not Found Untuk Rute Dinamis

## 1. Membuat File Not Found

Untuk membuat halaman Not Found, Anda perlu menambahkan file `not-found.tsx` di dalam direktori `src/app/`.

### Struktur Direktori

## Dynamic Imports

Anda dapat menggunakan dynamic imports untuk memuat komponen atau halaman berdasarkan kebutuhan.

```jsx
// pages/dynamic.js
import dynamic from 'next/dynamic';

const DynamicComponent = dynamic(() => import('../components/HeavyComponent'), {
  loading: () => <p>Loading...</p>,
});

const DynamicPage = () => {
  return (
    <div>
      <h1>Dynamic Import Example</h1>
      <DynamicComponent />
    </div>
  );
};

export default DynamicPage;
```

## Middleware

App Router mendukung penggunaan middleware untuk menambahkan logika custom sebelum masuk ke halaman tertentu.

#### Contoh Middleware

```jsx
// middleware/auth.js
import { NextResponse } from 'next/server';

export function middleware(request) {
  const isLoggedIn = checkUserLoggedIn(); // Implementasi fungsi login
  if (!isLoggedIn) {
    return NextResponse.redirect('/login');
  }
  return NextResponse.next();
}

function checkUserLoggedIn() {
  // Logika untuk memeriksa apakah pengguna sudah login
  return true; // Contoh: selalu menganggap pengguna sudah login
}
```

#### Menggunakan Middleware

```jsx
// pages/dashboard.js
import { middleware } from '../middleware/auth';

export const getServerSideProps = async (context) => {
  const response = middleware(context.req);
  if (response) {
    return response;
  }

  return {
    props: {}, // Props untuk halaman jika pengguna sudah login
  };
};

const Dashboard = () => {
  return <h1>Dashboard</h1>;
};

export default Dashboard;
```

## Advanced TypeScript di Next.js

Menggunakan TypeScript di Next.js memungkinkan kita untuk menulis kode yang lebih aman dan mudah dipelihara. TypeScript memberikan pengetikan statis yang kuat sehingga kita bisa menangkap error sebelum kode dijalankan [ref](https://www.youtube.com/watch?v=iS1K64X_eXg&list=WL&index=35).

### Interface Or Type

Keduanya, `type` dan `interface` memiliki kegunaannya masing-masing dalam TypeScript, dan pilihan antara keduanya tergantung pada kasus penggunaan spesifik serta preferensi pribadi. Berikut adalah beberapa pertimbangan untuk memilih di antara keduanya:

#### Interface

##### Kelebihan:

- Ekstending<br/>
  interface dapat diperluas atau digabungkan, memungkinkan penambahan properti baru tanpa mengubah definisi asli.

  ```ts
  interface Person {
    name: string;
  }

  interface Employee extends Person {
    employeeId: number;
  }

  const employee: Employee = {
    name: 'John',
    employeeId: 123,
  };
  ```

- Implementasi Kelas<br/>
  interface dapat diimplementasikan oleh kelas, memastikan bahwa kelas tersebut mengikuti struktur tertentu.

  ```ts
  interface Animal {
    makeSound(): void;
  }

  class Dog implements Animal {
    makeSound() {
      console.log('Bark');
    }
  }

  const myDog = new Dog();
  myDog.makeSound(); // Output: Bark
  ```

- Deklarasi Merging<br/>
  interface memungkinkan deklarasi yang sama digabungkan, yang dapat bermanfaat dalam beberapa situasi seperti penambahan properti pada objek global.

  ```ts
  interface Window {
    customProperty: string;
  }

  interface Window {
    anotherCustomProperty: number;
  }

  window.customProperty = 'Hello';
  window.anotherCustomProperty = 42;
  ```

##### Kekurangan:

Terbatas pada Object Types<br/>
interface biasanya digunakan untuk tipe objek, sehingga kurang fleksibel dibandingkan type yang dapat digunakan untuk berbagai macam tipe (union types, intersection types yang kompleks, dll.).

#### Type

##### Kelebihan:

- Fleksibilitas<br/>
  type lebih fleksibel dan dapat digunakan untuk mendefinisikan berbagai jenis tipe termasuk union, intersection, dan primitive types.

  - Union Types <br/>
    type memungkinkan kita untuk mendefinisikan tipe yang dapat berupa salah satu dari beberapa tipe yang berbeda. Ini dikenal sebagai Union Types.

    ```ts
    type StringOrNumber = string | number;

    const value1: StringOrNumber = 'Hello'; // Valid
    const value2: StringOrNumber = 42; // Valid
    const value3: StringOrNumber = true; // Error: Type 'boolean' is not assignable to type 'StringOrNumber'.
    ```

    Di sini, StringOrNumber adalah tipe yang bisa berupa string atau number. Kita bisa menggunakan type untuk mendefinisikan bahwa variabel atau parameter yang bisa menerima beberapa tipe data.

  - Intersection Types<br/>
    type juga memungkinkan kita untuk menggabungkan beberapa tipe menjadi satu menggunakan Intersection Types. Ini memungkinkan kita untuk mencampur beberapa tipe menjadi tipe baru.

    ```ts
    type Person = { name: string; age: number };
    type Address = { street: string; city: string };

    type PersonWithAddress = Person & Address;

    const individual: PersonWithAddress = {
      name: 'John',
      age: 30,
      street: '123 Main St',
      city: 'Somewhere',
    };
    ```

    Di sini, PersonWithAddress adalah tipe yang menggabungkan Person dan Address. Ini memungkinkan kita untuk memiliki properti dari kedua tipe dalam satu objek.

  - Primitive Types <br/>
    type juga bisa digunakan untuk mendefinisikan alias untuk tipe primitif seperti string, number, boolean, dan lain-lain.

    ```ts
    type ID = string;

    const userId: ID = 'user123'; // Valid
    const orderId: ID = 'order456'; // Valid
    ```

    Dalam contoh ini, ID adalah alias untuk string. Ini membuat kode lebih mudah dibaca dan mengurangi kemungkinan kesalahan tipe.

- Kompleks Tipe<br/>
  type dapat dengan mudah digunakan untuk mendefinisikan tipe yang kompleks, termasuk union dan intersection types, yang memungkinkan penggabungan beberapa tipe menjadi satu.

  ```ts
  type Status = 'pending' | 'approved' | 'rejected'; // Union type
  type Timestamp = number;
  type LogEntry = { message: string; timestamp: Timestamp };

  type DetailedLog = LogEntry & { status: Status }; // Intersection type

  const log: DetailedLog = {
    message: 'Transaction completed',
    timestamp: Date.now(),
    status: 'approved',
  };
  ```

  Di sini, DetailedLog adalah tipe yang menggabungkan LogEntry dan Status, sehingga mencakup semua properti dari kedua tipe tersebut.

##### Kekurangan:

Tidak dapat Digabungkan<br/>
Berbeda dengan interface, type tidak mendukung deklarasi merging. Sekali didefinisikan, Anda tidak bisa menambahkan properti tambahan ke dalam type yang sama di tempat lain. Berikut contohnya:

- Deklarasi Merging Menggunakan Interface

  ```ts
  interface User {
    name: string;
    age: number;
  }

  // Menambahkan properti baru ke interface User di tempat lain
  interface User {
    email: string;
  }

  const user: User = {
    name: 'John',
    age: 30,
    email: 'john@example.com',
  };
  ```

  Pada contoh di atas, kita mendefinisikan interface User dengan properti name dan age, kemudian di bagian lain dari kode kita menambahkan properti email ke interface yang sama. Ini dikenal sebagai deklarasi merging, yang hanya didukung oleh interface.

- Type Tidak Mendukung Deklarasi Merging

  ```ts
  type User = {
    name: string;
    age: number;
  };

  // Menambahkan properti baru ke tipe User di tempat lain (akan menyebabkan error)
  type User = {
    email: string;
  };

  // Alternatifnya kita harus mendefinisikan tipe baru yang menggabungkan kedua tipe
  type ExtendedUser = User & {
    email: string;
  };

  const user: ExtendedUser = {
    name: 'John',
    age: 30,
    email: 'john@example.com',
  };
  ```

  Pada contoh di atas, jika kita mencoba mendefinisikan type User lagi dengan properti email, TypeScript akan menghasilkan error karena type tidak mendukung deklarasi merging. Sebagai solusi, kita harus mendefinisikan tipe baru ExtendedUser yang menggabungkan User dengan tambahan properti email menggunakan intersection type (&).

  Jadi:

  - Interface: Mendukung deklarasi merging, sehingga kita bisa menambahkan properti baru ke interface yang sama di bagian lain dari kode.
  - Type: Tidak mendukung deklarasi merging. Jika kita perlu menambahkan properti baru, kita harus mendefinisikan tipe baru yang menggabungkan tipe sebelumnya dengan tambahan properti menggunakan intersection type.

#### Case Yang Mengharuskan menggunakan Type Dibanding Interface

Untuk kasus-kasus di mana intersection types kompleks dan melibatkan kombinasi berbagai tipe objek atau tipe dengan atribut khusus, penggunaan type sering kali lebih fleksibel dan lebih mudah dikelola dibandingkan interface. Berikut adalah beberapa contoh kasus yang mungkin memerlukan type daripada interface untuk intersection types yang kompleks:

1. Menggabungkan Tipe dengan Tipe Literal dan Primitif <br/>
   Terkadang, kita mungkin perlu menggabungkan tipe objek dengan literal types atau tipe primitif. type dapat memudahkan penggabungan berbagai tipe dalam satu tipe.

   ```ts
   type Person = {
     name: string;
     age: number;
   };

   type Employee = {
     employeeId: string;
     department: string;
   };

   type DetailedEmployee = Person &
     Employee & {
       position: 'manager' | 'developer' | 'designer'; // Tipe literal
       hiredDate: Date; // Tipe primitif
     };

   const detailedEmployee: DetailedEmployee = {
     name: 'Alice',
     age: 30,
     employeeId: 'E12345',
     department: 'Engineering',
     position: 'developer',
     hiredDate: new Date('2023-01-15'),
   };
   ```

   DetailedEmployee menggabungkan Person dan Employee dengan tambahan tipe literal (position) dan tipe primitif (hiredDate). type memungkinkan kombinasi fleksibel dari berbagai tipe, termasuk literal dan primitif.

2. Menggabungkan Tipe dengan Tipe Union yang Kompleks <br/>
   Ketika kita memiliki tipe objek yang perlu digabungkan dengan tipe union yang kompleks, type memungkinkan kita untuk menggabungkan ini dengan lebih mudah.

   ```ts
   type BasicInfo = {
     name: string;
     age: number;
   };

   type Status = 'active' | 'inactive';

   type DetailedStatus = BasicInfo & {
     status: Status;
     lastUpdated: Date;
   };

   const detailedStatus: DetailedStatus = {
     name: 'Bob',
     age: 45,
     status: 'active',
     lastUpdated: new Date(),
   };
   ```

   DetailedStatus menggabungkan BasicInfo dengan Status, yang merupakan union type. type memudahkan penggabungan objek dengan tipe union.

3. Menyusun Tipe dengan Tipe yang Berbeda-Beda <br/>
   Jika kita perlu menyusun tipe yang melibatkan objek, array, dan union types dalam satu tipe kompleks, type memberikan fleksibilitas lebih dalam menyusun tipe-tipe ini.

   ```ts
   type Product = {
     id: number;
     name: string;
   };

   type Pricing = {
     price: number;
     discount?: number;
   };

   type Review = {
     reviewer: string;
     rating: number;
   };

   type ProductDetails = Product &
     (Pricing | Review) & {
       inStock: boolean;
     };

   const productDetails: ProductDetails = {
     id: 1,
     name: 'Laptop',
     price: 1200,
     discount: 100,
     inStock: true,
   };
   ```

   ProductDetails menggabungkan Product dengan Pricing atau Review menggunakan union type Pricing | Review. Ini menggabungkan objek dengan tipe union serta tipe tambahan.

4. Menyusun Struktur Data dengan Kompleksitas Tinggi <br/>
   Ketika struktur data melibatkan nested objects atau kombinasi tipe yang sangat kompleks, type sering lebih mudah dikelola karena kemampuannya untuk menyusun berbagai tipe dengan cara yang lebih terintegrasi.

   ```ts
   type Address = {
     street: string;
     city: string;
     postalCode: string;
   };

   type ContactInfo = {
     email: string;
     phone: string;
   };

   type UserProfile = {
     username: string;
     profilePictureUrl?: string;
     address: Address;
     contact: ContactInfo;
   };

   const userProfile: UserProfile = {
     username: 'john_doe',
     profilePictureUrl: 'https://example.com/john_doe.jpg',
     address: {
       street: '123 Elm St',
       city: 'Springfield',
       postalCode: '12345',
     },
     contact: {
       email: 'john@example.com',
       phone: '555-1234',
     },
   };
   ```

   UserProfile menyusun objek dengan struktur data kompleks, termasuk nested objects seperti Address dan ContactInfo. type memungkinkan penyusunan tipe data yang kompleks dengan mudah.

#### Kasus yang Mengharuskan Menggunakan interface Dibanding type

Dalam TypeScript, baik interface maupun type digunakan untuk mendefinisikan tipe objek. Namun, ada beberapa kasus tertentu di mana penggunaan interface lebih disarankan dibandingkan type. Berikut adalah beberapa situasi di mana interface lebih unggul:

1. Deklarasi Merging<br/>
   Interface memungkinkan deklarasi merging, yaitu kemampuan untuk mendefinisikan ulang interface yang sama di tempat lain dalam kode dan menambahkan properti baru. Ini sangat berguna dalam aplikasi besar atau ketika menggunakan library pihak ketiga.

   ```ts
   interface User {
     name: string;
     age: number;
   }

   // Menambahkan properti baru di tempat lain
   interface User {
     email: string;
   }

   const user: User = {
     name: 'John',
     age: 30,
     email: 'john@example.com',
   };
   ```

   Pada contoh di atas, kita dapat menambahkan properti email ke User di bagian lain dari kode, tanpa mengubah definisi asli.

2. Inheritance yang Lebih Sederhana<br/>
   Interface mendukung multiple inheritance secara langsung, yang berarti satu interface dapat meng-extend beberapa interface lain, memudahkan dalam penggabungan berbagai tipe data yang kompleks.

   ```ts
   interface Nameable {
     name: string;
   }

   interface Ageable {
     age: number;
   }

   interface Person extends Nameable, Ageable {
     email: string;
   }

   const person: Person = {
     name: 'Jane',
     age: 25,
     email: 'jane@example.com',
   };
   ```

   Di sini, Person meng-extend Nameable dan Ageable, sehingga memiliki properti name dan age secara otomatis.

3. Penggunaan dengan Class<br/>
   Interface sering digunakan untuk mendefinisikan kontrak atau blueprint untuk class. Ini membantu dalam memastikan bahwa class yang mengimplementasikan interface harus memenuhi semua persyaratan yang ditentukan oleh interface.

   ```ts
   interface Animal {
     name: string;
     makeSound(): void;
   }

   class Dog implements Animal {
     name: string;

     constructor(name: string) {
       this.name = name;
     }

     makeSound() {
       console.log('Woof! Woof!');
     }
   }

   const myDog = new Dog('Buddy');
   myDog.makeSound(); // Output: Woof! Woof!
   ```

   Di sini, Dog mengimplementasikan interface Animal, sehingga harus memiliki properti name dan metode makeSound.

4. Mendukung Implementasi Explicit<br/>
   Interface memungkinkan deklarasi explicit dari properti dan metode yang harus diimplementasikan oleh class, memberikan lebih banyak kontrol dan kejelasan dalam desain aplikasi.

   ```ts
   interface Drivable {
     startEngine(): void;
     stopEngine(): void;
   }

   class Car implements Drivable {
     startEngine() {
       console.log('Engine started');
     }

     stopEngine() {
       console.log('Engine stopped');
     }
   }

   const myCar = new Car();
   myCar.startEngine(); // Output: Engine started
   myCar.stopEngine(); // Output: Engine stopped
   ```

   Class Car harus menyediakan implementasi untuk semua metode yang didefinisikan dalam interface Drivable.

5. Desain yang Lebih Jelas dan Terstruktur <br/>
   Dengan interface, Anda dapat merancang sistem tipe yang lebih jelas dan terstruktur, khususnya dalam aplikasi skala besar. Interface membantu dalam mendokumentasikan tipe objek dengan lebih baik dan menyediakan kontrak yang eksplisit untuk pengembangan tim.

### Component Props Typing

Dalam pengembangan komponen React dengan TypeScript, mendefinisikan tipe properti (props) adalah praktik yang sangat penting. Dengan menentukan tipe props, kita memastikan bahwa komponen kita menerima input yang sesuai dan mengurangi kemungkinan terjadinya bug [ref](https://www.youtube.com/watch?v=iS1K64X_eXg&list=WL&index=35&t=4m13s).
Dalam project yang lebih kompleks, kita mungkin memiliki komponen dengan berbagai tipe props. Berikut adalah contoh komponen product card yang lebih kompleks:

```js
// src/components/component_props/User.tsx

interface UserShape {
  name: string;
  age: number;
}

const User = ({ name, age }: UserShape) => {
  return (
    <main>
      <h1>{name}</h1>
      <h1>{age}</h1>
    </main>
  );
};

export default User;
```

Berikut contoh penggunaan component yang type props nya sudah di-define tadi

```js
// src/app/advanced-typescript-in-next/components-props-typing/page.tsx

import User from '@/components/advanced_typescript/component_props/User';
import React from 'react';

const ComponentPropTyping = () => {
  return (
    <div>
      <h1>Component Prop Typing User:</h1>
      <User name="John Doe" age={30} />
    </div>
  );
};

export default ComponentPropTyping;
```

Keuntungan Component Props Typing:

- Keamanan dan Konsistentsi<br/>
  Dengan TypeScript, kita mendapatkan pemeriksaan tipe statis, yang membantu mengidentifikasi kesalahan sebelum kode dijalankan.
- Autocompletion<br/>
  Editor kode seperti VSCode memberikan saran otomatis untuk properti dan metode berdasarkan tipe yang didefinisikan, yang meningkatkan produktivitas.
- Dokumentasi yang Lebih Baik<br/>
  Tipe props berfungsi sebagai dokumentasi bagi developer lain yang mungkin bekerja dengan komponen kita di masa depan.
- Refactoring yang Lebih Mudah<br/>
  Dengan tipe yang jelas, melakukan refaktorisasi kode menjadi lebih mudah dan aman karena kita dapat memastikan perubahan tidak merusak bagian lain dari kode.

Dengan menggunakan Component Props Typing di TypeScript, kita dapat membuat aplikasi Next.js yang lebih robust, terstruktur, dan mudah dipelihara.

### Children Types

Dalam pengembangan aplikasi web, penanganan children menjadi hal yang sangat penting, terutama dalam membangun komponen yang reusable dan fleksibel [ref](https://www.youtube.com/watch?v=iS1K64X_eXg&list=WL&index=35&t=11m04s). Children merupakan properti spesial di React yang memungkinkan Kita untuk menyisipkan komponen atau elemen lainnya ke dalam sebuah komponen. Kita akan membahas bagaimana cara mengelola children dengan TypeScript untuk meningkatkan keamanan tipe dan keandalan aplikasi kita. Menggunakan TypeScript untuk mendefinisikan tipe children membantu dalam:

- Menjamin Konsistensi<br/>
  Memastikan bahwa komponen menerima dan mengelola tipe data yang sesuai.
- Mencegah Kesalahan<br/>
  Mengidentifikasi kesalahan tipe selama pengembangan daripada saat runtime.
- Meningkatkan Pemeliharaan Kode<br/>
  Membuat kode lebih mudah dipahami dan dikelola oleh tim developer.

Berikut adalah beberapa cara untuk mendefinisikan children pada komponen:

#### Children sebagai React Node <br/>

Cara paling umum untuk mendefinisikan children adalah dengan menggunakan tipe React.ReactNode. Tipe ini mencakup semua elemen yang dapat dirender oleh React, termasuk string, angka, elemen JSX, fragment, dan array dari elemen-elemen tersebut. Contoh implementasinya misalnya pada aplikasi besar seperti dashboard admin, kita sering memiliki tata letak yang konsisten dengan sidebar, header, dan konten utama yang berubah-ubah. Dengan menggunakan children sebagai React Node, kita bisa membuat <b>Dashboard Layout Component</b> yang memungkinkan kita dengan mudah mengganti konten utama tanpa mengubah tata letak lainnya.

```tsx
// src/components/children_as_reactnode/DashboardLayout.tsx
import { ReactNode } from 'react';

interface DashboardLayoutProps {
  children: ReactNode;
}

const DashboardLayout = ({ children }: DashboardLayoutProps) => {
  return (
    <div className="flex flex-col min-h-screen">
      <header className="bg-blue-600 text-white p-4">Header</header>
      <div className="flex flex-1">
        <aside className="bg-gray-200 w-1/4 p-4">Sidebar</aside>
        <main className="flex-1 p-4">{children}</main>
      </div>
      <footer className="bg-gray-800 text-white p-4">Footer</footer>
    </div>
  );
};

export default DashboardLayout;
```

Berikut cara penggunaan component `DashboarLayout` tersebut

```tsx
// src/app/advanced-typescript-in-next/children-types/children-as-reactnode/page.tsx

import React from 'react';
import DashboardLayout from '@/components/DashboardLayout';

const ChildrenType = () => {
  return (
    <DashboardLayout>
      Kontent utama Children Types bagian children sebagai React Node{' '}
    </DashboardLayout>
  );
};

export default ChildrenType;
```

#### Children sebagai Fungsi Render<br/>

Ada kalanya children yang kita terima adalah sebuah fungsi yang menghasilkan elemen React. Ini bisa digunakan untuk skenario advanced seperti render props. Untuk mengimplementasikannya Kita akan membuat komponen DataFetcher yang mengambil data dari API dan memungkinkan penggunaan berbagai UI tergantung pada status pengambilan data (loading, error, success) melalui fungsi render.

```tsx
// src/components/advanced_typescript/children_types/children_as_render_function/DataFetcher.tsx

'use client';

import { ReactNode, useEffect, useState } from 'react';
import axios from 'axios';

interface DataFetcherProps {
  endpoint: string;
  children: (data: any, isLoading: boolean, error: Error | null) => ReactNode;
}

const DataFetcher = ({ endpoint, children }: DataFetcherProps) => {
  const [data, setData] = useState<any>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setIsLoading(true);
        const response = await axios.get(endpoint);
        setData(response.data);
      } catch (error) {
        setError(error as Error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [endpoint]);

  return <>{children(data, isLoading, error)}</>;
};

export default DataFetcher;
```

Berikut Penggunaan komponen `DataFetcher` tersebut

```tsx
// src/app/advanced-typescript-in-next/children-types/children-as-render-function/page.tsx

'use client';

import React from 'react';
import DataFetcher from '@/components/advanced_typescript/children_types/children_as_render_function/DataFetcher';

const ChildrenAsRenderFunction = () => {
  return (
    <DataFetcher endpoint={'https://jsonplaceholder.typicode.com/posts'}>
      {(data, isLoading, error) => {
        {
          console.log(isLoading);
        }
        if (isLoading) return <p>Loading...</p>;
        if (error)
          return <p className="text-red-500">Error: {error.message}</p>;
        if (!data) return <p>No data available.</p>;
        return (
          <div>
            <h1 className="text-2xl font-bold">Posts</h1>
            <ul>
              {data.map((post: any) => (
                <li key={post.id} className="p-4 border-b">
                  <h2 className="text-xl font-bold">{post.title}</h2>
                  <p>{post.body}</p>
                </li>
              ))}
            </ul>
          </div>
        );
      }}
    </DataFetcher>
  );
};

export default ChildrenAsRenderFunction;
```

- `DataFetcher` adalah komponen yang mengambil data dari API berdasarkan endpoint yang diberikan dan menggunakan children sebagai fungsi render untuk memberikan kontrol penuh kepada komponen yang menggunakannya tentang bagaimana menampilkan data.
- Di `ChildrenAsRenderFunction` page, `DataFetcher` digunakan untuk mengambil data postingan dari API jsonplaceholder. Fungsi render children digunakan untuk menampilkan status loading, error, atau data yang berhasil diambil.

#### Children dengan Tipe Khusus<br/>

kita juga dapat menentukan bahwa children harus memiliki tipe tertentu. Misalnya, kita memiliki sebuah aplikasi e-commerce dan kita ingin membuat komponen ProductList yang hanya menerima elemen `<li>` sebagai children.

- Component Product List <br/>
  Komponen ini dirancang untuk menerima children yang berupa elemen `<li>` atau array dari elemen `<li>`. Tipe `ReactElement<HTMLLIElement>` memastikan bahwa hanya elemen `<li>` yang diterima sebagai children.

  ```tsx
  // src/components/advanced_typescript/children_types/children_dengan_type_khusus/ProductList.tsx

  import React, { ReactElement } from 'react';

  interface ProductListProps {
    children: ReactElement<HTMLLIElement> | ReactElement<HTMLLIElement>[];
  }

  const ProductList = ({ children }: ProductListProps) => {
    return <ul className=" p-4  space-y-2 rounded-md">{children}</ul>;
  };

  export default ProductList;
  ```

- Component Product Item<br/>
  Komponen ini merepresentasikan item produk individual. Ia menerima props berupa id, name, price, dan description yang kemudian dirender dalam elemen `<li>`.

  ```tsx
  //src/components/advanced_typescript/children_types/children_dengan_type_khusus/ProductItem.tsx

  import React from 'react';

  interface ProductType {
    id: number;
    name: string;
    price: number;
    description: string;
  }

  const ProductItem = ({ id, name, price, description }: ProductType) => {
    return (
      <li className="mb-2 p-4 border-b bg-gray-200 rounded-md">
        <h2 className="text-xl font-bold">{name}</h2>
        <p>{description}</p>
        <p className="text-red-500 font-bold">IDR {price}</p>
      </li>
    );
  };

  export default ProductItem;
  ```

- Product Page<br/>
  Halaman ini menggunakan ProductList dan ProductItem untuk merender daftar produk.

  ```tsx
  import ProductItem from '@/components/advanced_typescript/children_types/children_dengan_type_khusus/ProductItem';
  import ProductList from '@/components/advanced_typescript/children_types/children_dengan_type_khusus/ProductList';
  import React from 'react';

  const ProductPage = () => {
    const productData = [
      {
        id: 1,
        name: 'Product 1',
        description: 'Description for product 1',
        price: 100000,
      },
      {
        id: 2,
        name: 'Product 2',
        description: 'Description for product 2',
        price: 150000,
      },
      {
        id: 3,
        name: 'Product 3',
        description: 'Description for product 3',
        price: 200000,
      },
    ];

    return (
      <div className="p-6">
        <h1 className="text-3xl font-bold mb-4">Products</h1>
        <ProductList>
          {productData.map((product) => (
            <ProductItem
              key={product?.id}
              id={product?.id}
              name={product?.name}
              description={product?.description}
              price={product?.price}
            />
          ))}
        </ProductList>
      </div>
    );
  };

  export default ProductPage;
  ```

#### Optional Children <br/>

Dalam beberapa kasus, children mungkin tidak selalu diperlukan. kita bisa membuatnya opsional dengan menambahkan tanda `?`. Dalam contoh ini, kita akan membuat dua komponen: `Card` dan `ProfileCard`. `Card` adalah komponen umum yang bisa menerima children, sedangkan `ProfileCard` adalah contoh bagaimana kita menggunakan `Card` dengan children yang opsional.

- Card Component

  ```tsx
  // src/components/advanced_typescript/children_types/optional_children/Card.tsx

  import React, { ReactNode } from 'react';

  interface CardProps {
    title: string;
    children?: ReactNode; // optional children
  }

  const Card = ({ title, children }: CardProps) => {
    return (
      <div className="border p-4 rounded shadow-md ">
        <h2 className="text-2xl font-bold mb-4">{title}</h2>
        {children && <div className="mt-2">{children}</div>}
      </div>
    );
  };

  export default Card;
  ```

- ProfileCard Component

  ```tsx
  // src/components/advanced_typescript/children_types/optional_children/Card.tsx

  import React from 'react';
  import Card from './Card';

  interface ProfileCardProps {
    name: string;
    age: number;
    bio?: string; // optional bio
  }

  const ProfileCard = ({ name, age, bio }: ProfileCardProps) => {
    return (
      <Card title="Profile">
        <p className="text-lg"> Name: {name}</p>
        <p className="text-lg">Age: {age}</p>
        {bio && <p className="text-lg">Bio: {bio}</p>}
      </Card>
    );
  };

  export default ProfileCard;
  ```

- Profile Page

  ```tsx
  // src/app/advanced-typescript-in-next/children-types/optional-children/page.tsx

  import ProfileCard from '@/components/advanced_typescript/children_types/optional_children/ProfileCard';
  import React from 'react';

  const ProfilePage = () => {
    return (
      <div className="p-6 space-y-4">
        <ProfileCard
          name="John Doe"
          age={30}
          bio="Software Engineer at Microsoft"
        />
        <ProfileCard name="Jane Doe" age={25} />
      </div>
    );
  };

  export default ProfilePage;
  ```

  Dengan contoh ini, kita memiliki komponen `Card` yang mendukung children opsional. Komponen `ProfileCard` menggunakan `Card` dan memiliki properti opsional `bio`. Di halaman ProfilePage, kita menggunakan `ProfileCard` dengan dan tanpa `bio` untuk menunjukkan bagaimana children opsional bekerja.

### FC Functional Components & TypeScript

Dalam pengembangan aplikasi modern menggunakan React dan TypeScript, menggunakan Functional Components (FC) memiliki banyak manfaat. Menggabungkan TypeScript dengan FC membantu dalam penulisan kode yang lebih aman, terstruktur, dan mudah dipelihara [ref](https://www.youtube.com/watch?v=iS1K64X_eXg&list=WL&index=35&t=1791s). Berikut ini manfaat penggunaan FC dan TypeScript:

- Type Safety<br/>
  Dengan TypeScript, kita dapat mendefinisikan tipe data yang diharapkan oleh komponen, sehingga membantu mencegah bug dan kesalahan tipe yang umum terjadi pada JavaScript.
- Readability dan Maintainability<br/>
  Kode yang ditulis dengan FC lebih mudah dibaca dan dipelihara. TypeScript menambah kejelasan dengan menyediakan tipe untuk props dan state.
- Intellisense<br/>
  TypeScript menyediakan fitur auto-completion yang sangat membantu dalam pengembangan, membuat penulisan kode lebih cepat dan akurat.
- Refactoring<br/>
  Dengan adanya tipe data, refactoring kode menjadi lebih aman dan mudah dilakukan tanpa harus khawatir merusak fungsionalitas yang sudah ada.

Berikut adalah contoh penggunaan Functional Components dengan TypeScript, Kita akan menggunakan contoh komponen yang menampilkan daftar buku.

```tsx
// src/components/advanced_typescript/functional_component_typescript/Book.tsx

import React, { FC } from 'react';

interface BookType {
  title: string;
  author: string;
}

const Book: FC<BookType> = ({ title, author }) => {
  return (
    <main>
      <h1>{title}</h1>
      <h1>{author}</h1>
    </main>
  );
};

export default Book;
```

Berikut cara penggunaan component `Book` tersebut

```tsx
// src/app/advanced-typescript-in-next/functional-component-typescript/page.tsx

import Book from '@/components/advanced_typescript/functional_component_typescript/Book';

const UserPage = () => {
  return (
    <div>
      <Book title="Bulan memeluk Bumi" author="Usop" />
    </div>
  );
};

export default UserPage;
```

### Dynamic Routes & TypeScript

Dynamic routes di Next.js memungkinkan kita untuk membuat halaman yang dihasilkan berdasarkan parameter URL yang dinamis. Dengan menggunakan TypeScript, kita bisa menambahkan tipe yang kuat dan dukungan autocompletion ke dalam rute dinamis, memastikan bahwa kita menangani data dengan cara yang aman dan konsisten [ref](https://www.youtube.com/watch?v=iS1K64X_eXg&list=WL&index=36&t=1791s).

Dynamic routes memungkinkan kita membuat halaman yang dapat merespons parameter dalam URL. Misalnya, kita bisa memiliki halaman produk yang diakses melalui URL seperti `/article/[id]`, di mana `[id]` adalah parameter dinamis yang menentukan produk yang akan ditampilkan.

#### Struktur Folder dan Penamaan File <br/>

Untuk membuat dynamic route di Next.js, kita perlu menggunakan sintaks nama file dengan kurung siku `([ ])`. Misalnya, jika kita ingin membuat halaman detail article berdasarkan ID produk, kita akan membuat file dengan nama` [id]/page.tsx` di dalam folder `app/advanced-typescript-in-next/dinamic-routes-typescript/article/`.

```md
src/
|-- app/
|------| advanced-typescript-in-next/
|-----------------------------------| dinamic-routes-typescriptarticle/
|---------------------------------------------------------------------| article/
|------------------------------------------------------------------------------| [id]/
|------------------------------------------------------------------------------------| page.tsx
|-- index.tsx
```

2. Membuat Komponen Halaman dengan Dynamic Route <br/>
   Berikut adalah contoh di mana kita dapat mengimplementasikan halaman dinamis dengan TypeScript di Next.js:

   ```tsx
   // src/app/advanced-typescript-in-next/dinamic-routes-typescript/article/[id].tsx

   import React from 'react';

   interface ArticleProps {
     params: { id: number };
   }

   const DetailArticle = ({ params: { id } }: ArticleProps) => {
     return <div>DetailArticle Id: {id}</div>;
   };

   export default DetailArticle;
   ```

### Reusable Types dalam TypeScript

TypeScript memungkinkan kita untuk mendefinisikan tipe data yang dapat digunakan kembali di seluruh aplikasi kita. Ini sangat berguna dalam proyek besar di mana konsistensi dan pemeliharaan kode adalah kunci. Dengan Reusable Types, kita dapat mendefinisikan tipe data sekali dan menggunakannya di banyak tempat, meningkatkan efisiensi dan mengurangi kemungkinan kesalahan. Reusable Types adalah tipe data yang kita buat di TypeScript dan dapat digunakan di berbagai bagian aplikasi kita. Ini memungkinkan kita untuk mendefinisikan tipe data secara konsisten di seluruh aplikasi, sehingga menghindari duplikasi dan memudahkan pemeliharaan [ref](https://www.youtube.com/watch?v=iS1K64X_eXg&list=WL&index=36&t=1791s).

Berikut adalah contoh bagaimana kita membuat reusable types menggunakan interface untuk BaseInputProps dan ExtendedInputTypes, serta menunjukkan penggunaannya dalam komponen yang sesuai.

#### Buat type yang akan dijadikan reusable types <br/>

```ts
// src/types/InputTypes

export interface BasicInputTypes {
  label: string;
  placeholder: string;
}

export interface AdvancedInputTypes extends BasicInputTypes {
  isRequired?: boolean;
  maxLength?: number;
}
```

2. Buat component `BasicInput` yang menggunakan type `BasicInputTypes`

   ```ts
   // src/components/advanced_typescript/reusable_types/BasicInput.tsx

   import { BasicInputTypes } from '@/types/InputTypes';

   const BasicInput = ({ label, placeholder }: BasicInputTypes) => {
     return (
       <div>
         <label htmlFor="">
           {label}
           <input
             type="text"
             placeholder={placeholder}
             className="p-2 border rounded"
           />
         </label>
       </div>
     );
   };

   export default BasicInput;
   ```

3. Buat component `AdvancedInput` menggunakan type `AdvancedInputTypes`

   ```tsx
   // src/components/advanced_typescript/reusable_types/AdvancedInput.tsx

   import { AdvancedInputTypes } from '@/types/InputTypes';

   const AdvancedInput = ({
     label,
     placeholder,
     isRequired,
     maxLength,
   }: AdvancedInputTypes) => {
     return (
       <div>
         <label>
           {label}
           <input
             type="text"
             placeholder={placeholder}
             required={isRequired}
             maxLength={maxLength}
             className="p-2 border rounded"
           />
         </label>
       </div>
     );
   };

   export default AdvancedInput;
   ```

4. Buat page form menggunakan component `BasicInput` dan `AdvancedInput`

   ```tsx
   // src/app/advanced-typescript-in-next/reusable-types/page.tsx

   import AdvancedInput from '@/components/advanced_typescript/reusable_types/AdvancedInput';
   import BasicInput from '@/components/advanced_typescript/reusable_types/BasicInput';
   import React from 'react';

   const FormPage = () => {
     return (
       <div className="p-6">
         <h1 className="text-2xl font-bold mb-4">Form</h1>
         <BasicInput label="Basic Input" placeholder="Enter your mind" />
         <AdvancedInput
           label="Advanced Input"
           placeholder="Enter your mind"
           isRequired
           maxLength={10}
         />
       </div>
     );
   };

   export default FormPage;
   ```

Penjelasan:

1. File src/types/InputTypes.ts<br/>

   - BaseInputTypes<br/>
     Interface dasar untuk properti input, seperti label dan placeholder.
   - ExtendedInputTypes<br/>
     Interface yang memperluas BaseInputTypes dengan properti tambahan seperti isRequired dan maxLength.

2. File BasicInput.tsx<br/>
   Komponen BasicInput menggunakan BaseInputTypes untuk mendukung properti dasar seperti label dan placeholder.
3. File AdvancedInput.tsx<br/>
   Komponen AdvancedInput menggunakan ExtendedInputTypes untuk mendukung properti tambahan seperti isRequired dan maxLength.
4. File FormPage.tsx<br/>
   Menggunakan BasicInput dan AdvancedInput untuk menunjukkan bagaimana kedua komponen ini bisa digunakan dalam sebuah halaman form.

Dengan contoh ini, kita bisa melihat bagaimana interface yang dasar dan yang di-extend bisa digunakan dalam komponen yang berbeda, memberikan fleksibilitas dalam penggunaan properti komponen.

### Menggunakan useState dengan TypeScript

React Hook useState adalah salah satu cara paling umum untuk mengelola state dalam komponen fungsional. Ketika menggunakan TypeScript, Anda mendapatkan keuntungan tambahan berupa pemeriksaan tipe yang ketat, yang membantu memastikan bahwa state dan tindakan terhadap state dikelola dengan benar. Berikut adalah beberapa cara untuk menggunakan useState dengan TypeScript:

1. Menggunakan useState dengan Tipe Primitif<br/>
   Untuk state dengan tipe data primitif seperti string, number, atau boolean, TypeScript biasanya dapat menginfer tipe dari nilai awal. Namun, Anda juga bisa menentukan tipe secara eksplisit.
2. Menggunakan useState dengan Tipe Kompleks
   Untuk state dengan tipe kompleks, seperti objek atau array, Anda bisa secara eksplisit menentukan tipe state untuk memastikan keamanan tipe yang lebih baik.
3. Menggunakan useState dengan Union Types
   Terkadang state Anda mungkin memiliki lebih dari satu tipe yang mungkin. Dalam kasus ini, Anda bisa menggunakan union types.

Berikut adalah contoh lengkap yang menunjukkan penggunaan useState dengan tipe primitif, kompleks, dan union types:

```tsx
// src/app/advanced-typescript-in-next/use-state-typescript/page.tsx

'use client';

import React, { useState } from 'react';

interface User {
  name: string;
  age: number;
}

const UstateTypsriptPage = () => {
  // advanced-typescript-in-next/use-state-typescript/page.tsx
  // Tipe Primitif
  const [count, setCount] = useState<number>(0);
  const [name, setName] = useState<string>('');

  // Union Types
  const [value, setValue] = useState<string | number>('Empat Puluh Dua');

  //   Tipe Kompleks
  const [users, setUsers] = useState<User[]>([]);

  return (
    <>
      {/* Tipe Primitif */}
      <div className="p-6 border rounded-sm bg-slate-200">
        <h2>Tipe Primitif</h2>
        <p>Count: {count}</p>
        <button
          onClick={() => setCount((count) => count + 1)}
          className="px-4 py-2 rounded-lg bg-blue-950 text-white hover:bg-blue-800"
        >
          Increment
        </button>
        <input
          type="text"
          value={name}
          className="block p-2"
          onChange={(e) => setName(e.target.value)}
        />
      </div>

      {/* Union Types */}
      <div className="p-6 border rounded-sm bg-slate-200">
        <h2>Union Types</h2>
        <p>Value: {value}</p>
        <button
          className="px-4 py-2 rounded-lg bg-blue-950 text-white hover:bg-blue-800"
          onClick={() =>
            setValue(value === 'Empat Puluh Dua' ? 42 : 'Empat Puluh Dua')
          }
        >
          Toggle Value
        </button>
        <input
          type="text"
          className="block p-2"
          onChange={(e) => setValue(e.target.value)}
        />
      </div>

      {/* Tipe Kompleks */}
      <div className="p-6 border rounded-sm bg-slate-200">
        <h2>Tipe Kompleks</h2>

        <h2>Tipe Kompleks</h2>
        <button
          className="px-4 py-2 rounded-lg bg-blue-950 text-white hover:bg-blue-800"
          onClick={() => setUsers([...users, { name: 'Alice', age: 30 }])}
        >
          Add User
        </button>
        <ul>
          {users?.map((user, index) => (
            <li key={index}>
              <p>User Name: {user.name}</p>
              <p>User Age: {user.age}</p>
            </li>
          ))}
        </ul>
      </div>
    </>
  );
};

export default UstateTypsriptPage;
```

### Best Practices Penggunaan Forms, useRef, dan Events dalam TypeScript

Berikut peran ketiganya [ref](https://www.youtube.com/watch?v=iS1K64X_eXg&list=WL&index=36&t=1791s):

- Forms<br/>
  Forms digunakan untuk mengumpulkan dan mengelola data dari input user. Dalam React dengan TypeScript, kita dapat mendefinisikan tipe data yang diharapkan dari form untuk memastikan integritas data. Misalnya, form untuk menambahkan user baru dengan input untuk name dan age.
- useRef<br/>
  useRef digunakan untuk mendapatkan referensi ke elemen DOM atau menyimpan nilai yang tidak memicu rendering ulang. Dalam konteks forms, useRef memungkinkan akses langsung ke nilai input tanpa harus mengikatnya ke state, yang bisa lebih efisien. Sehingga bisa mengingkatkan Efisiensi Kinerja:
  - Tanpa Re-rendering<br/>
    Saat menggunakan useRef, kita dapat mengakses dan mengubah nilai input tanpa menyebabkan komponen melakukan re-render. Ini meningkatkan kinerja, terutama pada komponen dengan banyak input atau komponen yang kompleks.
  - State Management<br/>
    Mengurangi jumlah state yang perlu dikelola dapat membuat aplikasi lebih efisien. Setiap kali state diperbarui, komponen akan di-render ulang, jadi dengan mengurangi penggunaan state, kita dapat mengurangi jumlah re-render yang tidak perlu.
- Events<br/>
  Events adalah cara untuk menangani interaksi user, seperti klik atau submit form. TypeScript menyediakan tipe untuk event handlers yang memastikan fungsi event menangani tipe data yang tepat, membantu mencegah bug dan membuat kode lebih aman dan mudah dipahami.
  Berikut contoh penggunaannya:

```tsx
// src/app/advanced-typescript-in-next/base-practice-penggunaan-forms-useref-event/page.tsx

'use client';

import React, { FormEvent, useRef, useState } from 'react';

interface UserType {
  name: string;
  age: number;
}

const FormUserefEventpage = () => {
  const [users, setUsers] = useState<UserType[]>([]);
  const nameRef = useRef<HTMLInputElement>(null);
  const ageRef = useRef<HTMLInputElement>(null);

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    const name = nameRef.current?.value;
    const ageString = ageRef.current?.value;
    const age = ageString ? parseInt(ageString) : NaN;

    if (name && age) {
      console.log(name, age);
      setUsers([...users, { name, age }]);
      if (nameRef.current) nameRef.current.value = '';
      if (ageRef.current) ageRef.current.value = '';
    }
    console.log(users);
  };

  return (
    <div>
      <h2>User Registration</h2>
      <form onSubmit={handleSubmit}>
        <div>
          <label>
            Name:
            <input type="text" ref={nameRef} />
          </label>
        </div>
        <div>
          <label>
            Age:
            <input type="number" ref={ageRef} />
          </label>
        </div>
        <button type="submit">Add User</button>
      </form>
      <h2>Registered Users</h2>
      <ul>
        {users.map((user, index) => (
          <li key={index}>
            {user.name} - {user.age} years old
          </li>
        ))}
      </ul>
    </div>
  );
};

export default FormUserefEventpage;
```

- Forms<br/>
  Mengumpulkan data user (nama dan usia) melalui input.
- useRef<br/>
  Mendapatkan referensi ke elemen input nama dan usia untuk mengakses nilai mereka tanpa mengikatnya ke state.
- Events<br/>
  handleSubmit menangani event form submission, mencegah default submission, mengambil nilai input, dan memperbarui state dengan user baru.

### Memahami Context API & TypeScript

Context API adalah fitur di React yang memungkinkan kita untuk berbagi nilai (seperti tema, data user, pengaturan aplikasi) antara komponen tanpa harus mengirimkan props secara manual melalui setiap level dari komponen. Ketika digabungkan dengan TypeScript, Context API menjadi lebih kuat dan aman karena kita dapat menentukan tipe data yang diteruskan melalui context. Context API sangat berguna untuk:

- Mengurangi Prop Drilling<br/>
  Menghindari pengiriman props melalui banyak lapisan komponen.
- State Management<br/>
  Menyediakan state global untuk aplikasi atau bagian besar dari aplikasi.
- Konfigurasi Global<br/>
  Menyimpan pengaturan global seperti tema atau bahasa.

Mari kita lihat contoh bagaimana mengatur Context API dengan TypeScript. Kita akan membuat context untuk fitur counter di dalam aplikasi.

- Context Setup<br/>
  Pertama-tama, kita akan membuat file CountContext.tsx yang mendefinisikan Context API kita.

  ```tsx
  // src/context/CountContext.tsx

  'use client';

  import { createContext, ReactNode, useContext, useState } from 'react';

  interface CountContextType {
    count: number;
    increment: () => void;
    decrement: () => void;
  }

  const CountContext = createContext<CountContextType | undefined>(undefined);

  export const CountWrapper = ({ children }: { children: ReactNode }) => {
    const [count, setCount] = useState(0);
    const increment = () => setCount((prevCount) => prevCount + 1);
    const decrement = () => setCount((prevCount) => prevCount - 1);

    return (
      <CountContext.Provider value={{ count, increment, decrement }}>
        {children}
      </CountContext.Provider>
    );
  };

  export const useCountContext = () => {
    const context = useContext(CountContext);

    if (!context) {
      throw new Error('useCountContext must be used within a CountWrapper');
    }

    return context;
  };
  ```

- Menggunakan User Context dalam Komponen <br/>
  Sekarang kita buat komponen untuk untuk menampilkan informasi dan action counter.

  ```tsx
  // src/components/advanced_typescript/context_api/CounterComponent.tsx

  import { useCountContext } from '@/context/CountContext';
  import React from 'react';

  const CounterComponent = () => {
    const { count, increment, decrement } = useCountContext();

    return (
      <div>
        <p>Count: {count}</p>
        <button onClick={increment}>Increment</button>
        <button onClick={decrement}>Decrement</button>
      </div>
    );
  };

  export default CounterComponent;
  ```

  Komponen CounterComponent ini menampilkan nilai count serta menyediakan dua tombol untuk mengincrement dan mendekrement nilai count.

- Menggunakan Context di Layout <br/>
  Terakhir, kita akan mengubah layout utama kita untuk menggunakan CountWrapper sehingga semua komponen di dalamnya memiliki akses ke context.

  ```tsx
  // src/app/layout.tsx

  import type { Metadata } from 'next';
  // import { Inter, Playfair_Display } from 'next/font/google';
  import { oswald } from './fonts';
  import './globals.css';
  import Navbar from '@/components/Navbar';
  import { CountWrapper } from '@/context/CountContext';

  // const inter = Inter({
  //   subsets: ['latin'],
  //   display: 'swap',
  //   variable: '--font-inter',
  //   // preload: false,
  // });

  // const playfair = Playfair_Display({
  //   subsets: ['latin'],
  //   display: 'swap',
  //   variable: '--font-playfair-display',
  //   // preload: false,
  // });

  export const metadata: Metadata = {
    title: {
      default: 'Next 14 Playground',
      template: '%s | Next 14 Playground',
    },
    description: 'Next 14 Playground, playing around with Next 14',
  };

  export default function RootLayout({
    children,
  }: Readonly<{
    children: React.ReactNode;
  }>) {
    return (
      // <html lang="en" className={`${inter.variable} ${playfair.variable}`}>
      <html lang="en">
        <head>
          <link rel="icon" href="/icon.ico" sizes="any" />
          <link rel="icon" href="/icon.png" type="image/png" sizes="16x16" />
          <link
            rel="icon"
            href="/apple-icon.png"
            type="image/png"
            sizes="16x16"
          />
          <link
            rel="apple-touch-icon"
            href="/icon.png"
            type="image/png"
            sizes="16x16"
          />
        </head>
        <body
          className={`${oswald.className} p-4 min-h-screen flex flex-col bg-gray-100`}
        >
          <header>
            <Navbar />
          </header>
          <CountWrapper>
            <main>{children}</main>
          </CountWrapper>
          <footer className="border-t py-3 text-center text-xs">
            I&lsquo;m here to stay (Footer)
          </footer>
        </body>
      </html>
    );
  }
  ```

  Dengan perubahan ini, semua komponen yang berada di dalam CountWrapper akan memiliki akses ke context CountContext.

### useReducer dengan TypeScript

useReducer adalah hook yang powerful dalam React untuk mengelola state yang lebih kompleks. Dengan TypeScript, kita dapat menambahkan tipe yang kuat untuk memastikan keamanan dan keandalan kode. Mari kita lihat bagaimana cara menggunakan useReducer dengan TypeScript. Kita sebaiknya menggunakan useReducer ketika:

- State memiliki struktur yang kompleks.
- Banyak aksi yang berbeda yang mempengaruhi state.
- Logika pembaruan state yang rumit.

Sekarang, mari kita lihat contoh yang lebih kompleks, seperti aplikasi Todo List.

1. Definisikan Tipe Todo<br/>
   Buat file types/TodoTypes.ts dan tambahkan tipe-tipe todo

   ```ts
   // src/types/TodoTypes.ts

   export interface TodoType {
     id: number;
     title: string;
     completed: boolean;
   }

   export type TodoListType = TodoType[];

   export type TodoActionType =
     | { type: 'ADD_TODO'; title: string }
     | { type: 'TOGGLE_TODO'; id: number }
     | { type: 'REMOVE_TODO'; id: number };
   ```

2. Buat Reducer <br/>
   Di sini, kita membuat fungsi todoReducer yang mengelola state Todo berdasarkan action yang diterima.

   ```ts
   // src/reducers/TodoReducer.ts

   import { TodoActionType, TodoListType } from '@/types/TodoTypes';

   export const todoReducer = (
     todoList: TodoListType,
     todoAction: TodoActionType
   ): TodoListType => {
     switch (todoAction.type) {
       case 'ADD_TODO':
         return [
           ...todoList,
           {
             id: Date.now(),
             title: todoAction.title,
             completed: false,
           },
         ];
       case 'TOGGLE_TODO':
         return todoList.map((todo) =>
           todo.id === todoAction.id
             ? { ...todo, completed: !todo.completed }
             : todo
         );
       case 'REMOVE_TODO':
         return todoList.filter((todo) => todo.id !== todoAction.id);
       default:
         return todoList;
     }
   };
   ```

3. Komponen TodoApp <br/>
   Di components/TodoApp.tsx, kita menggunakan useReducer untuk mengelola state Todo dan memberikan fungsi untuk menambah, toggle, dan menghapus Todo.

   ```tsx
   // src/components/advanced_typescript/reducers/TodoApp.tsx

   'use client';

   import { todoReducer } from '@/reducers/TodoReducer';
   import { TodoActionType, TodoListType } from '@/types/TodoTypes';
   import React, { Reducer, useReducer, useState } from 'react';

   const TodoApp = () => {
     const [todoList, dispatch] = useReducer<
       Reducer<TodoListType, TodoActionType>
     >(todoReducer, []);
     const [todoTitle, setTodoTitle] = useState('');

     const handleAddTodo = () => {
       dispatch({ type: 'ADD_TODO', title: todoTitle });
       setTodoTitle('');
     };

     return (
       <div>
         <h1>Todo App</h1>
         <input
           type="text"
           value={todoTitle}
           onChange={(e) => setTodoTitle(e.target.value)}
         />
         <button onClick={handleAddTodo}>Add Todo</button>
         <ul>
           {todoList.map((todo) => (
             <li key={todo.id}>
               <span className={`${todo.completed ? 'line-through' : ''}`}>
                 {todo.title}
               </span>
               <button
                 onClick={() => dispatch({ type: 'TOGGLE_TODO', id: todo.id })}
               >
                 Completed
               </button>
               <button
                 onClick={() => dispatch({ type: 'REMOVE_TODO', id: todo.id })}
               >
                 Remove `
               </button>
             </li>
           ))}
         </ul>
       </div>
     );
   };

   export default TodoApp;
   ```

4. Reducer Page <br/>
   Disini kita import dan tampilakan komponent `TodoApp` (komponen yang menggunakan reducer)

   ```tsx
   // src/app/advanced-typescript-in-next/reducer/page.tsx

   import TodoApp from '@/components/advanced_typescript/reducers/TodoApp';
   import React from 'react';

   const TodoPage = () => {
     return (
       <div>
         <TodoApp />
       </div>
     );
   };

   export default TodoPage;
   ```

### Menggunakan Global Types dengan TypeScript

TypeScript adalah alat yang kuat untuk menambahkan tipe statis ke JavaScript, yang membantu pengembangan aplikasi lebih aman dan mudah dipelihara. Salah satu fitur penting dari TypeScript adalah kemampuan untuk mendefinisikan tipe global yang dapat digunakan di seluruh aplikasi kita. Kali ini kita akan membahas cara mendefinisikan dan menggunakan tipe global dalam proyek TypeScript.Berikut keuntungan menggunakan Global Types:

- Konsistensi<br/> Dengan menggunakan tipe global, kita memastikan bahwa tipe-tipe yang sama digunakan di seluruh aplikasi, mengurangi kesalahan dan ketidakkonsistenan.
- Pemeliharaan Mudah<br/> Jika ada perubahan pada tipe tertentu, kita hanya perlu mengubahnya di satu tempat.
- Dokumentasi Lebih Baik<br/> Tipe global membantu mendokumentasikan struktur data yang digunakan dalam aplikasi kita.

Mari kita buat sebuah contoh di mana kita menggunakan tipe global untuk menampilkan data user dalam aplikasi.

1.  Definisikan Tipe Global <br/>
    Pertama, kita perlu untuk mendefinisikan tipe global kita

    ```ts
    // src/types/UserTypes.d.ts

    interface UserType {
      id: number;
      name: string;
      email: string;
    }
    ```

2.  Gunakan Tipe Global <br/>
    Sekarang, kita akan menggunakan tipe User yang telah kita definisikan dalam komponen React.

    ````tsx
    import React from 'react';

        const user: UserType = {
          id: 1,
          name: 'John Doe',
          email: 'jdoe@me.com',
        };

        const GlobalTypePage = () => {
          return (
            <div>
              <h1>Global Types</h1>
              <p>Id: {user.id}</p>
              <p>Name: {user.name} </p>
              <p>Email: {user.email}</p>
            </div>
          );
        };

        export default GlobalTypePage;
        ```
    ````
